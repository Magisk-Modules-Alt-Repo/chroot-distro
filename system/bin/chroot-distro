#!/system/bin/sh
#
# Copyright 2024 Yasser Null
#
# Code is licensed under terms of GNU GPL v3, see LICENSE file
# for the full terms.

chroot_distro_path="/data/local/chroot-distro"
script=$(basename "$0")

if [ "$(whoami)" != "root" ]; then
    echo "Root access required."
    exit 1
fi

if [ "$(uname -m)" = "aarch64" ] || [ "$(uname -m)" = "arm64" ]; then
    hardware_machine="arm64"
elif [ "$(uname -m)" = "arm" ] || [ "$(uname -m)" = "armel" ] || [ "$(uname -m)" = "armhf" ] || [ "$(uname -m)" = "armhfp" ] || [ "$(uname -m)" = "armv7" ] || [ "$(uname -m)" = "armv7l" ] || [ "$(uname -m)" = "armv7a" ] || [ "$(uname -m)" = "armv8l" ]; then
    hardware_machine="armhf"
elif [ "$(uname -m)" = "386" ] || [ "$(uname -m)" = "i386" ] || [ "$(uname -m)" = "i686" ] || [ "$(uname -m)" = "x86" ]; then
    hardware_machine="i386"
elif [ "$(uname -m)" = "amd64" ] || [ "$(uname -m)" = "x86_64" ]; then
    hardware_machine="amd64"
else
    echo "Unsupported machine hardware: $(uname -m)"
    exit 1
fi

check_env=''
if [ $# -ge 1 ] && [ "env" = "$1" ]; then
    check_env=true
fi

if [ "" = "$check_env" ]; then
    : # do nothing
elif [ -e /data/adb/modules/chroot-distro ]; then
    echo "Script: $0"
    hash=$(md5sum "$0" | cut -d " " -f1)
    if cmp -s "$0" /data/adb/modules/chroot-distro/system/bin/chroot-distro; then
        (
            module_prop=$(cat /data/adb/modules/chroot-distro/module.prop)
            echo "$module_prop" | while read -r row; do
                field=$(echo "$row" | cut -d "=" -f 1 )
                value=$(echo "$row" | cut -d "=" -f 2 )
                case "$field" in
                    version) echo "Version: $value" ;;
                    versionCode) echo "Versioncode: $value" ;;
                esac
            done
            echo "md5 hash: $hash"
        )
    else
        echo "Not matching installed version, md5 hash: $hash"
    fi
else
    echo "Script: $0"
    echo "Unknown version, md5 hash: $(md5sum "$0" | cut -d " " -f1)"
fi

if [ "" != "$check_env" ]; then
    echo "Toybox version: $(toybox --version)"
fi

busyboxpath="$(command -v busybox 2> /dev/null)"
# shellcheck disable=SC2181
# need both ouput and error code thus needs indirect error checking
if [ $? -ne 0 ]; then
    busyboxpath=''
    if [ -e /data/adb ]; then
        # try harder... -- thanks for the pointer, @osm0sis
        if [ "" != "$check_env" ]; then
            echo 'Checking for hidden Busyboxes'
        fi
        for possiblepath in /data/adb/modules/busybox-ndk/system/*/busybox /data/adb/magisk/busybox /data/adb/ksu/bin/busybox /data/adb/ap/bin/busybox; do
            if [ "" = "$busyboxpath" ] && [ -f "$possiblepath" ]; then
                busyboxpath="$possiblepath"
            fi
        done;
    fi
    if [ "" = "$check_env" ] && [ "" = "$busyboxpath" ]; then
        echo "busybox not found, install Busybox for Android NDK and try again"
        echo "Run '$script env' for extra information"
        exit 1
    fi
fi

if [ "" != "$check_env" ]; then
    echo "busybox => '$busyboxpath'"
    if [ "" != "$busyboxpath" ]; then
        echo "Busybox version: $($busyboxpath | head -n1)"
    fi
fi

unsupported_busybox=''
case "$busyboxpath" in
    /bin/*) ;; # assume that it is ok (either old android, or linux), nothing to do
    /system/*)
        ndk_path=/system/xbin/busybox
        if [ "$busyboxpath" != "$ndk_path" ] && [ -e "$ndk_path" ]; then
            # force use of Busybox for Android NDK in the case there is conflicting versions
            if [ "" != "$check_env" ]; then
                echo "Forcing Busybox path from '$busyboxpath' to '$ndk_path'"
                echo "Forced Busybox version: $($ndk_path | head -n1)"
            fi
            busyboxpath="$ndk_path"
        fi
    ;;
    /data/adb/modules/busybox-ndk/system/*) ;; # hidden Busybox for Android NDK, nothing to do
    /data/adb/magisk/*) unsupported_busybox=true ;; # Magisk without Busybox for Android NDK installed
    /usr/bin/*) ;; # running linux, assume that all is ok, nothing to do
    /data/adb/ksu/bin/*) unsupported_busybox=true ;; # KernelSU without Busybox for Android NDK installed
    /data/adb/ap/bin/*) unsupported_busybox=true ;; # APatch without Busybox for Android NDK installed
    *)
        if [ "" = "$check_env" ]; then
            echo "busybox not found from the expected path, ensure that Busybox for Android NDK has been installed and try again"
            echo "Run '$script env' for extra information"
            exit 1
        fi
    ;;
esac

busyboxdir="$(dirname "$busyboxpath")"
can_use_busyboxdir=true
if [ "" = "$busyboxpath" ]; then
    # not found
    can_use_busyboxdir=''
elif [ "/system/bin" = "$busyboxdir" ]; then
    # would use Toybox version always, skip
    can_use_busyboxdir=''
elif [ "/usr/bin" = "$busyboxdir" ]; then
    # would use full/normal chroot command, skip to ensure consistent test environment
    can_use_busyboxdir=''
fi
if [ "" != "$can_use_busyboxdir" ] &&  [ -e "$busyboxdir"/chroot ]; then
    # Use chroot from the expected Busybox
    chrootpath="$(dirname "$busyboxpath")"/chroot
elif [ -e /system/xbin/chroot ]; then
    # Use a Busybox version
    chrootpath=/system/xbin/chroot
elif [ -e /system/bin/chroot ]; then
    # Fall back to Toybox version
    chrootpath=/system/bin/chroot
else
    # don't want to use a random chroot to ensure it doesn't affect the jail
    chrootpath=''
fi
unset can_use_busyboxdir
unset busyboxdir

if [ "" = "$check_env" ] && [ "" = "$chrootpath" ]; then
    echo "chroot not found from the expected path, ensure that Busybox for Android NDK has been installed and try again"
    echo "Run '$script env' for extra information"
    exit 1
fi

busyboxlsofcaller=''
busyboxlsof=''
if [ "" != "$busyboxpath" ] && "$busyboxpath" lsof > /dev/null 2>&1; then
    # prefer the version provided by the found busybox binary
    busyboxlsofcaller=true
    busyboxlsof=true
    lsofpath='busybox lsof'
elif [ -e /system/xbin/lsof ]; then
    # busybox version
    lsofpath=/system/xbin/lsof
    busyboxlsof=true
elif [ -e /system/bin/lsof ]; then
    # toybox version
    lsofpath=/system/bin/lsof
else
    # don't want to use random lsof as it may not work (or has different output)
    # in this case user has to manually run the command
    lsofpath=''
fi

# ensure that the expected version of busybox is used
busybox() { "$busyboxpath" "$@"; }

# Toybox uname does not support -p
uname() {
    if [ "" != "$busyboxpath" ]; then
        busybox uname "$@";
    else
        # fall back to defaults to ensure at least some output
        uname -a
    fi
}

# ensure that busybox version of getopt is used
getopt() { busybox getopt "$@"; }

# ensure that busybox version of tar is used
tar() { busybox tar "$@"; }

# ensure that busybox version of wget is used
wget() { busybox wget "$@"; }

# ensure that correct version of chroot is used
chroot() { "$chrootpath" "$@"; }

lsof() {
    if [ "" != "$busyboxlsofcaller" ]; then
        busybox lsof
    elif [ "" = "$lsofpath" ]; then
        # lsof is optional, no output
        :
    else
        "$lsofpath";
    fi
}

if [ "" != "$check_env" ]; then
    echo "chroot => '$chrootpath'"
    if [ "" = "$chrootpath" ]; then
        echo "chroot found in PATH (but not used) => '$(command -v chroot 2> /dev/null)'"
    fi
    echo "lsof => '$lsofpath'"
    if [ "" = "$lsofpath" ]; then
        echo "lsof found in PATH (but not used) => '$(command -v lsof 2> /dev/null)'"
    fi
    if [ ! -e /data/adb ]; then
        echo 'Could not determine the type of root solution installed'
    elif [ -e /data/adb/magisk ]; then
        case "$hardware_machine" in
            *64)
                if [ -e /data/adb/magisk/magisk64 ]; then
                    magiskbin=/data/adb/magisk/magisk64
                elif [ -e /data/adb/magisk/magisk ]; then
                    magiskbin=/data/adb/magisk/magisk
                fi
                if [ "" != "$magiskbin" ]; then
                    magisk_version=$($magiskbin -v)
                else
                    magisk_version=Unknown
                fi
            ;;
            *)
                if [ -e /data/adb/magisk/magisk32 ]; then
                    magiskbin=/data/adb/magisk/magisk32
                elif [ -e /data/adb/magisk/magisk ]; then
                    magiskbin=/data/adb/magisk/magisk
                fi
                if [ "" != "$magiskbin" ]; then
                    magisk_version=$($magiskbin -v)
                else
                    magisk_version=Unknown
                fi
            ;;
        esac
        echo "Magisk installed ($magisk_version)"
    elif [ -e /data/adb/ksu ]; then
        # would be nice if the version information could be provided, patches welcome
        echo 'KernelSU installed (version not known)'
    elif [ -e /data/adb/ap ]; then
        # would be nice if the version information could be provided, patches welcome
        echo 'APatch installed (version not known)'
    else
        echo 'Unknown root solution, possible candidates:'
        for candidate in /data/adb/*; do
            if [ -d "$candidate" ]; then
                dirname=$(basename "$candidate")
                case "$dirname" in
                    modules) ;; # not interested
                    post-fs-data.d) ;; # not interested
                    service.d) ;; # not interested
                    *) echo "$dirname" ;;
                esac
            fi
        done
        echo 'list end'
    fi
    if [ ! -e /data/adb ]; then
        echo 'Could not determine if Busybox for Android NDK Magisk module is installed'
    elif [ -e /data/adb/modules/busybox-ndk ]; then
        echo 'Busybox for Android NDK Magisk module installed'
    else
        echo 'Busybox for Android NDK Magisk module not installed'
    fi
    # don't want machine name, otherwise -a would be easiest
    if [ "unknown" != "$(uname -p)" ]; then
        uname -s -r -v -m -p -i -o
    else
        uname -s -r -v -m -o
    fi
    echo "PATH=$PATH"
    # check run successfully, bail out
    exit 0
fi

getopt --test > /dev/null && true
if [ $? -ne 4 ]; then
    # shellcheck disable=SC2016
    echo 'I'\''m sorry, `getopt --test` failed in this environment.'
    echo "Run '$script env' for extra information"
    exit 1
fi

# get a unique name
non_existent_file=$(mktemp -u)

tar_output=$(tar -t -J -f "$non_existent_file.tar.xz" 2>&1)
if [ "1" = "$(echo "$tar_output" | grep -i -c "(invalid|unknown) option")" ]; then
    echo 'Your Busybox tar does not support xz compression. Update your busybox!'
    echo "Run '$script env' for extra information"
    exit 1
fi

unset non_existent_file

if [ ! -d "$chroot_distro_path/" ]; then
    mkdir -p $chroot_distro_path/
fi

if [ ! -d "$chroot_distro_path/.rootfs/" ]; then
    mkdir -p $chroot_distro_path/.rootfs/
fi
if [ ! -d "$chroot_distro_path/.backup/" ]; then
    mkdir -p $chroot_distro_path/.backup/
fi

chroot_distro_warn_if_unsupported_busybox() {
    if [ "" != "$unsupported_busybox" ]; then
        echo "Warning: You are using Magisk/KernelSU/APatch without Busybox for Android NDK installed."
        echo "You may experience bugs as this is community supported environment."
    fi
}

chroot_distro_help() {
    echo "$script : install linux distributions

usage :

$script help - for more information
$script env - output debug information about environment
$script list - list of available linux distributions

$script download <distro> - download rootfs
$script redownload <distro> - redownload rootfs
$script delete <distro> - delete rootfs

$script install <distro> [-a|--android] - install distro
    '-a|--android'  Installs also /data and /system folders, by default not installed
$script reinstall <distro> [-a|--android] [-f|--force] - reinstall distro
    '-a|--android'  Installs also /data and /system folders, by default not installed
    '-f|--force'    Force closing open files (closes the process accessing them)
                    and/or unmounting active mounts. Use with care.
$script uninstall <distro> [-f|--force] - uninstall distro
    '-f|--force'    Force closing open files (closes the process accessing them)
                    and/or unmounting active mounts. Use with care.

$script unmount <distro> [-f|--force] [-a|--all] - unmount (system) mount points from distro
    '-f|--force'    Force closing open files (closes the process accessing them)
                    and/or unmounting active mounts which prevents (system) mount points
                    from unmounting. Use with care.
    '-a|--all'      Instead of unmounting only system mount points, will try to unmount
                    all found mount points, be it a normal mount point or a loopback mount point.

$script backup <distro> [<path>] - backup distro
    <path>          Custom path for backup location
$script restore <distro> [-d|--default] [--force] [<path>] - restore distro
    <path>          Custom path for backup location
    '-d|--default'  restore default settings (note: only those set during install)
    '--force'       Force restore even if may cause unintended side-effects
$script unbackup <distro> - delete backup from default location

$script command <distro> <command> - run command
$script login <distro> - login to distro
"

    chroot_distro_warn_if_unsupported_busybox
}

chroot_distro_list_item() {
    if [ -f "$chroot_distro_path/.rootfs/$1.tar.xz" ]; then
        echo "Downloaded : Yes"
    else
        echo "Downloaded : No"
    fi
    if [ -d "$chroot_distro_path/$1/" ]; then
        echo "Installed: Yes"
    else
        echo "Installed: No"
    fi
    if [ -f "$chroot_distro_path/.backup/$1.tar.xz" ]; then
        echo "Backup : Yes"
    else
        echo "Backup : No"
    fi
    echo
}

chroot_distro_list() {
    echo "Ubuntu : ubuntu
Rootfs : https://cdimage.ubuntu.com/ubuntu-base/releases/"
    chroot_distro_list_item ubuntu
    echo "Kali Linux : kali
Rootfs : http://kali.download/nethunter-images/"
    chroot_distro_list_item kali
    echo "Debian : debian
Rootfs : https://github.com/EXALAB/Anlinux-Resources/raw/master/Rootfs/Debian/
Rootfs : https://github.com/termux/proot-distro/releases/download/v4.7.0/"
    chroot_distro_list_item debian
    echo "Parrot OS : parrot
Rootfs : https://github.com/EXALAB/Anlinux-Resources/raw/master/Rootfs/Parrot/"
    chroot_distro_list_item parrot
    echo "Alpine : alpine
Rootfs : http://dl-cdn.alpinelinux.org/alpine/latest-stable/releases/"
    chroot_distro_list_item alpine
    echo "Void Linux : void
Rootfs : https://repo-default.voidlinux.org/live/"
    chroot_distro_list_item void
    if [ "$hardware_machine" != "i386" ]; then
        echo "Arch Linux : archlinux
Rootfs : http://ca.us.mirror.archlinuxarm.org/os/
Rootfs : https://mirrors.ocf.berkeley.edu/archlinux/iso/latest/"
        chroot_distro_list_item archlinux
    fi
    if [ "$hardware_machine" = "arm64" ]; then
        echo "Artix Linux : artix
Rootfs : https://github.com/termux/proot-distro/releases/download/v4.6.0/"
        chroot_distro_list_item artix
    fi
    if [ "$hardware_machine" = "arm64" ] || [ "$hardware_machine" = "amd64" ]; then
        echo "Deepin : deepin
Rootfs : https://github.com/termux/proot-distro/releases/download/v4.6.0/"
        chroot_distro_list_item deepin
    fi
    if [ "$hardware_machine" = "arm64" ] || [ "$hardware_machine" = "amd64" ]; then
        echo "Fedora : fedora
Rootfs : https://github.com/termux/proot-distro/releases/download/v4.6.0/"
        chroot_distro_list_item fedora
    fi
    if [ "$hardware_machine" = "arm64" ]; then
        echo "Manjaro : manjaro
Rootfs : https://github.com/termux/proot-distro/releases/download/v4.6.0/"
        chroot_distro_list_item manjaro
    fi
    if [ "$hardware_machine" = "arm64" ] || [ "$hardware_machine" = "amd64" ]; then
        echo "OpenKylin : openkylin
Rootfs : https://github.com/termux/proot-distro/releases/download/v4.6.0/"
        chroot_distro_list_item openkylin
    fi
    if [ "$hardware_machine" != "armhf" ]; then
        echo "Pardus : pardus
Rootfs : https://github.com/termux/proot-distro/releases/download/v4.6.0/"
        chroot_distro_list_item pardus
    fi
    echo "OpenSuse : opensuse
Rootfs : https://github.com/termux/proot-distro/releases/download/v4.6.0/"
    chroot_distro_list_item opensuse
    echo "BackBox : backbox
Rootfs : https://github.com/EXALAB/Anlinux-Resources/raw/master/Rootfs/BackBox/"
    chroot_distro_list_item backbox
    if [ "$hardware_machine" = "arm64" ] || [ "$hardware_machine" = "amd64" ]; then
        echo "CentOS : centos
Rootfs : https://github.com/EXALAB/Anlinux-Resources/raw/master/Rootfs/CentOS/"
        chroot_distro_list_item centos
    fi
    if [ "$hardware_machine" = "arm64" ] || [ "$hardware_machine" = "amd64" ]; then
        echo "CentOS Stream : centos_stream
Rootfs : https://github.com/EXALAB/Anlinux-Resources/raw/master/Rootfs/CentOS_Stream/"
        chroot_distro_list_item centos_stream
    fi
}

chroot_distro_download() {
    if [ "$1" = "ubuntu" ]; then
        if [ "$hardware_machine" = "i386" ] || [ "$hardware_machine" = "arm64" ] || [ "$hardware_machine" = "armhf" ] || [ "$hardware_machine" = "amd64" ]; then
            echo "[1] ubuntu trusty 14.04.6"
        fi
        if [ "$hardware_machine" = "i386" ] || [ "$hardware_machine" = "arm64" ] || [ "$hardware_machine" = "armhf" ] || [ "$hardware_machine" = "amd64" ]; then
            echo "[2] ubuntu xenial 16.04.6"
        fi
        if [ "$hardware_machine" = "i386" ] || [ "$hardware_machine" = "arm64" ] || [ "$hardware_machine" = "armhf" ] || [ "$hardware_machine" = "amd64" ]; then
            echo "[3] ubuntu bionic 18.04.5"
        fi
        if [ "$hardware_machine" = "arm64" ] || [ "$hardware_machine" = "armhf" ] || [ "$hardware_machine" = "amd64" ]; then
            echo "[4] ubuntu focal 20.04.5"
        fi
        if [ "$hardware_machine" = "arm64" ] || [ "$hardware_machine" = "armhf" ] || [ "$hardware_machine" = "amd64" ]; then
            echo "[5] ubuntu jammy 22.04.4"
        fi
        if [ "$hardware_machine" = "arm64" ] || [ "$hardware_machine" = "armhf" ] || [ "$hardware_machine" = "amd64" ]; then
            echo "[6] ubuntu noble 24.04.1"
        fi
        while true; do
            printf "Enter a number : "
            read number
            case "$number" in
                1) rootfs="trusty";rootfs_version="14.04.6"; break;;
                2) rootfs="xenial";rootfs_version="16.04.6"; break;;
                3) rootfs="bionic";rootfs_version="18.04.5"; break;;
                4) rootfs="focal";rootfs_version="20.04.5"; break;;
                5) rootfs="jammy";rootfs_version="22.04.4"; break;;
                6) rootfs="noble";rootfs_version="24.04.1"; break;;
                *) echo "Unknown option : $number";;
            esac
        done
        if [ ! -f "$chroot_distro_path/.rootfs/$1.tar.xz" ]; then
            wget -O "$chroot_distro_path/.rootfs/$1.tar.xz" "https://cdimage.ubuntu.com/ubuntu-base/releases/$rootfs/release/ubuntu-base-$rootfs_version-base-$hardware_machine.tar.gz"
            if [ $? -ne 0 ]; then
                echo "Failed to download the Ubuntu Rootfs."
                rm $chroot_distro_path/.rootfs/$1.tar.xz
                exit
            fi
        else
            echo "Already downloaded."
        fi

    elif [ "$1" = "alpine" ]; then
        echo "[1] alpine minirootfs latest"
        echo "[2] alpine netboot latest"
        echo "[3] alpine rpi latest"
        echo "[4] alpine uboot latest"
        while true; do
            printf "Enter a number : "
            read number
            case "$number" in
                1) rootfs="minirootfs";break;;
                2) rootfs="netboot"; break;;
                3) rootfs="rpi"; break;;
                4) rootfs="uboot";break;;
                *) echo "Unknown option : $number";;
            esac
        done
        if [ ! -f "$chroot_distro_path/.rootfs/$1.tar.xz" ]; then
            hwm_alpine=$(echo $hardware_machine | sed s/arm64/aarch64/g | sed s/amd64/x86_64/g | sed s/i386/x86/g)
            wget -O "$chroot_distro_path/.rootfs/$1.tar.xz" "http://dl-cdn.alpinelinux.org/alpine/latest-stable/releases/$hwm_alpine/alpine-$rootfs-$(curl -s http://dl-cdn.alpinelinux.org/alpine/latest-stable/releases/$hwm_alpine/ | grep -oE 'alpine-.*[0-9]+\.[0-9]+\.[0-9]+[^"]*(.tar.gz|.tar|.img)' | sed -E 's/.*([0-9]+\.[0-9]+\.[0-9]+).*/\1/' | sort -V | tail -n 1)-$hwm_alpine.tar.gz"
            if [ $? -ne 0 ]; then
                echo "Failed to download the Alpine Rootfs."
                rm $chroot_distro_path/.rootfs/$1.tar.xz
                exit
            fi
        else
            echo "Already downloaded."
        fi

    elif [ "$1" = "kali" ]; then
        echo "[1] kali linux full 2024.1"
        echo "[2] kali linux minimal 2024.1"
        echo "[3] kali linux nano 2024.1"
        echo
        echo "[4] kali linux full 2023.4"
        echo "[5] kali linux minimal 2023.4"
        echo "[6] kali linux nano 2023.4"
        echo
        echo "[7] kali linux full 2023.3b"
        echo "[8] kali linux minimal 2023.3b"
        echo "[9] kali linux nano 2023.3b"
        echo
        echo "[10] kali linux full 2023.3"
        echo "[11] kali linux minimal 2023.3"
        echo "[12] kali linux nano 2023.3"
        echo
        echo "[13] kali linux full current"
        echo "[14] kali linux minimal current"
        echo "[15] kali linux nano current"
        while true; do
            printf "Enter a number : "
            read number
            case "$number" in
                1) rootfs="full";rootfs_version="kali-2024.1"; break;;
                2) rootfs="minimal";rootfs_version="kali-2024.1"; break;;
                3) rootfs="nano";rootfs_version="kali-2024.1"; break;;
                4) rootfs="full";rootfs_version="kali-2023.4"; break;;
                5) rootfs="minimal";rootfs_version="kali-2023.4"; break;;
                6) rootfs="nano";rootfs_version="kali-2023.4"; break;;
                7) rootfs="full";rootfs_version="kali-2023.3b"; break;;
                8) rootfs="minimal";rootfs_version="kali-2023.3b"; break;;
                9) rootfs="nano";rootfs_version="kali-2023.3b"; break;;
                10) rootfs="full";rootfs_version="kali-2023.3"; break;;
                11) rootfs="minimal";rootfs_version="kali-2023.3"; break;;
                12) rootfs="nano";rootfs_version="kali-2023.3"; break;;
                13) rootfs="full";rootfs_version="current"; break;;
                14) rootfs="minimal";rootfs_version="current"; break;;
                15) rootfs="nano";rootfs_version="current"; break;;
                *) echo "Unknown option : $number";;
            esac
        done
        if [ ! -f "$chroot_distro_path/.rootfs/$1.tar.xz" ]; then
            wget -O "$chroot_distro_path/.rootfs/$1.tar.xz" "http://kali.download/nethunter-images/$rootfs_version/rootfs/kalifs-$hardware_machine-$rootfs.tar.xz"
            if [ $? -ne 0 ]; then
                echo "Failed to download the Kali Linux Rootfs."
                rm $chroot_distro_path/.rootfs/$1.tar.xz
                exit
            fi
        else
            echo "Already downloaded."
        fi

    elif [ "$1" = "debian" ]; then
        echo "[1] Debian"
        echo "[2] Debian bullseye"
        echo "[3] Debian bookworm"
        while true; do
            printf "Enter a number : "
            read number
            case "$number" in
                1) rootfs="debian"; break;;
                2) rootfs="debian_bullseye"; break;;
                3) rootfs="debian_bookworm";break;;
                *) echo "Unknown option : $number";;
            esac
        done

        if [ ! -f "$chroot_distro_path/.rootfs/$1.tar.xz" ]; then
            if [ $rootfs = "debian" ]; then
                wget -O "$chroot_distro_path/.rootfs/$1.tar.xz" "https://github.com/EXALAB/Anlinux-Resources/raw/master/Rootfs/Debian/$hardware_machine/debian-rootfs-$hardware_machine.tar.xz"
            elif [ $rootfs = "debian_bullseye" ]; then
                wget -O "$chroot_distro_path/.rootfs/$1.tar.xz" "https://github.com/termux/proot-distro/releases/download/v4.7.0/debian-bullseye-$(echo $hardware_machine | sed s/arm64/aarch64/g | sed s/amd64/x86_64/g | sed s/i386/i686/g | sed s/armhf/arm/g)-pd-v4.7.0.tar.xz"
            elif [ $rootfs = "debian_bookworm" ]; then
                wget -O "$chroot_distro_path/.rootfs/$1.tar.xz" "https://github.com/termux/proot-distro/releases/download/v4.7.0/debian-bookworm-$(echo $hardware_machine | sed s/arm64/aarch64/g | sed s/amd64/x86_64/g | sed s/i386/i686/g | sed s/armhf/arm/g)-pd-v4.7.0.tar.xz"
            fi

            if [ $? -ne 0 ]; then
                echo "Failed to download the Debian Rootfs."
                rm $chroot_distro_path/.rootfs/$1.tar.xz
                exit
            fi
        else
            echo "Already downloaded."
        fi

    elif [ "$1" = "parrot" ]; then
        if [ ! -f "$chroot_distro_path/.rootfs/$1.tar.xz" ]; then
            wget -O "$chroot_distro_path/.rootfs/$1.tar.xz" "https://github.com/EXALAB/Anlinux-Resources/raw/master/Rootfs/Parrot/$hardware_machine/parrot-rootfs-$hardware_machine.tar.xz"
            if [ $? -ne 0 ]; then
                echo "Failed to download the Parrot OS Rootfs."
                rm $chroot_distro_path/.rootfs/$1.tar.xz
                exit
            fi
        else
            echo "Already downloaded."
        fi

    elif [ "$1" = "archlinux" ]; then
        if [ ! -f "$chroot_distro_path/.rootfs/$1.tar.xz" ]; then
            if [ "$hardware_machine" = "armhf" ]; then
                wget -O "$chroot_distro_path/.rootfs/$1.tar.xz" "http://ca.us.mirror.archlinuxarm.org/os/ArchLinuxARM-armv7-latest.tar.gz"
            elif [ "$hardware_machine" = "arm64" ]; then
                wget -O "$chroot_distro_path/.rootfs/$1.tar.xz" "http://ca.us.mirror.archlinuxarm.org/os/ArchLinuxARM-aarch64-latest.tar.gz"
            elif [ "$hardware_machine" = "amd64" ]; then
                wget -O "$chroot_distro_path/.rootfs/$1.tar.xz" "https://mirrors.ocf.berkeley.edu/archlinux/iso/latest/archlinux-bootstrap-x86_64.tar.gz"
            else
                echo "Unsupported machine hardware: $(uname -m)"
                exit
            fi
            if [ $? -ne 0 ]; then
                echo "Failed to download the Arch Linux Rootfs."
                rm $chroot_distro_path/.rootfs/$1.tar.xz
                exit
            fi
        else
            echo "Already downloaded."
        fi

    elif [ "$1" = "artix" ]; then
        if [ ! -f "$chroot_distro_path/.rootfs/$1.tar.xz" ]; then
            if [ "$hardware_machine" = "arm64" ]; then
                wget -O "$chroot_distro_path/.rootfs/$1.tar.xz" "https://github.com/termux/proot-distro/releases/download/v4.6.0/artix-aarch64-pd-v4.6.0.tar.xz"
            else
                echo "Unsupported machine hardware: $(uname -m)"
                exit
            fi
            if [ $? -ne 0 ]; then
                echo "Failed to download the Artix Linux Rootfs."
                rm $chroot_distro_path/.rootfs/$1.tar.xz
                exit
            fi
        else
            echo "Already downloaded."
        fi

    elif [ "$1" = "deepin" ]; then
        if [ ! -f "$chroot_distro_path/.rootfs/$1.tar.xz" ]; then
            if [ "$hardware_machine" = "arm64" ]; then
                wget -O "$chroot_distro_path/.rootfs/$1.tar.xz" "https://github.com/termux/proot-distro/releases/download/v4.6.0/artix-aarch64-pd-v4.6.0.tar.xz"
            elif [ "$hardware_machine" = "amd64" ]; then
                wget -O "$chroot_distro_path/.rootfs/$1.tar.xz" "https://github.com/termux/proot-distro/releases/download/v4.6.0/artix-x86_64-pd-v4.6.0.tar.xz"
            else
                echo "Unsupported machine hardware: $(uname -m)"
                exit
            fi
            if [ $? -ne 0 ]; then
                echo "Failed to download the Deepin Rootfs."
                rm $chroot_distro_path/.rootfs/$1.tar.xz
                exit
            fi
        else
            echo "Already downloaded."
        fi

    elif [ "$1" = "fedora" ]; then
        if [ ! -f "$chroot_distro_path/.rootfs/$1.tar.xz" ]; then
            if [ "$hardware_machine" = "arm64" ]; then
                wget -O "$chroot_distro_path/.rootfs/$1.tar.xz" "https://github.com/termux/proot-distro/releases/download/v4.6.0/fedora-aarch64-pd-v4.6.0.tar.xz"
            elif [ "$hardware_machine" = "amd64" ]; then
                wget -O "$chroot_distro_path/.rootfs/$1.tar.xz" "https://github.com/termux/proot-distro/releases/download/v4.6.0/fedora-x86_64-pd-v4.6.0.tar.xz"
            else
                echo "Unsupported machine hardware: $(uname -m)"
                exit
            fi
            if [ $? -ne 0 ]; then
                echo "Failed to download the Fedora Rootfs."
                rm $chroot_distro_path/.rootfs/$1.tar.xz
                exit
            fi
        else
            echo "Already downloaded."
        fi

    elif [ "$1" = "openkylin" ]; then
        if [ ! -f "$chroot_distro_path/.rootfs/$1.tar.xz" ]; then
            if [ "$hardware_machine" = "arm64" ]; then
                wget -O "$chroot_distro_path/.rootfs/$1.tar.xz" "https://github.com/termux/proot-distro/releases/download/v4.6.0/openkylin-aarch64-pd-v4.6.0.tar.xz"
            elif [ "$hardware_machine" = "amd64" ]; then
                wget -O "$chroot_distro_path/.rootfs/$1.tar.xz" "https://github.com/termux/proot-distro/releases/download/v4.6.0/openkylin-x86_64-pd-v4.6.0.tar.xz"
            else
                echo "Unsupported machine hardware: $(uname -m)"
                exit
            fi
            if [ $? -ne 0 ]; then
                echo "Failed to download the OpenKylin Rootfs."
                rm $chroot_distro_path/.rootfs/$1.tar.xz
                exit
            fi
        else
            echo "Already downloaded."
        fi

    elif [ "$1" = "manjaro" ]; then
        if [ ! -f "$chroot_distro_path/.rootfs/$1.tar.xz" ]; then
            if [ "$hardware_machine" = "arm64" ]; then
                wget -O "$chroot_distro_path/.rootfs/$1.tar.xz" "https://github.com/termux/proot-distro/releases/download/v4.6.0/manjaro-aarch64-pd-v4.6.0.tar.xz"
            else
                echo "Unsupported machine hardware: $(uname -m)"
                exit
            fi
            if [ $? -ne 0 ]; then
                echo "Failed to download the Manjaro Rootfs."
                rm $chroot_distro_path/.rootfs/$1.tar.xz
                exit
            fi
        else
            echo "Already downloaded."
        fi

    elif [ "$1" = "opensuse" ]; then
        if [ ! -f "$chroot_distro_path/.rootfs/$1.tar.xz" ]; then
            wget -O "$chroot_distro_path/.rootfs/$1.tar.xz" "https://github.com/termux/proot-distro/releases/download/v4.6.0/opensuse-$(echo $hardware_machine | sed s/arm64/aarch64/g | sed s/amd64/x86_64/g | sed s/i386/i686/g | sed s/armhf/arm/g)-pd-v4.6.0.tar.xz"
            if [ $? -ne 0 ]; then
                echo "Failed to download the OpenSuse Rootfs."
                rm $chroot_distro_path/.rootfs/$1.tar.xz
                exit
            fi
        else
            echo "Already downloaded."
        fi

    elif [ "$1" = "pardus" ]; then
        if [ ! -f "$chroot_distro_path/.rootfs/$1.tar.xz" ]; then
            if [ "$hardware_machine" != "armhf" ]; then
                wget -O "$chroot_distro_path/.rootfs/$1.tar.xz" "https://github.com/termux/proot-distro/releases/download/v4.6.0/pardus-$(echo $hardware_machine | sed s/arm64/aarch64/g | sed s/amd64/x86_64/g | sed s/i386/i686/g | sed s/armhf/arm/g)-pd-v4.6.0.tar.xz"
            else
                echo "Unsupported machine hardware: $(uname -m)"
                exit
            fi
            if [ $? -ne 0 ]; then
                echo "Failed to download the Pardus Rootfs."
                rm $chroot_distro_path/.rootfs/$1.tar.xz
                exit
            fi
        else
            echo "Already downloaded."
        fi

    elif [ "$1" = "backbox" ]; then
        if [ ! -f "$chroot_distro_path/.rootfs/$1.tar.xz" ]; then
            wget -O "$chroot_distro_path/.rootfs/$1.tar.xz" "https://github.com/EXALAB/Anlinux-Resources/raw/master/Rootfs/BackBox/$hardware_machine/backbox-rootfs-$hardware_machine.tar.xz"
            if [ $? -ne 0 ]; then
                echo "Failed to download the BackBox Rootfs."
                rm $chroot_distro_path/.rootfs/$1.tar.xz
                exit
            fi
        else
            echo "Already downloaded."
        fi

    elif [ "$1" = "centos" ]; then
        if [ ! -f "$chroot_distro_path/.rootfs/$1.tar.xz" ]; then
            if [ "$hardware_machine" = "arm64" ]; then
                wget -O "$chroot_distro_path/.rootfs/$1.tar.xz" "https://github.com/EXALAB/Anlinux-Resources/raw/master/Rootfs/CentOS/arm64/centos-rootfs-arm64.tar.xz"
            elif [ "$hardware_machine" = "amd64" ]; then
                wget -O "$chroot_distro_path/.rootfs/$1.tar.xz" "https://github.com/EXALAB/Anlinux-Resources/raw/master/Rootfs/CentOS/amd64/centos-rootfs-amd64.tar.xz"
            else
                echo "Unsupported machine hardware: $(uname -m)"
                exit
            fi
            if [ $? -ne 0 ]; then
                echo "Failed to download the CentOS Rootfs."
                rm $chroot_distro_path/.rootfs/$1.tar.xz
                exit
            fi
        else
            echo "Already downloaded."
        fi

    elif [ "$1" = "centos_stream" ]; then
        if [ ! -f "$chroot_distro_path/.rootfs/$1.tar.xz" ]; then
            if [ "$hardware_machine" = "arm64" ]; then
                wget -O "$chroot_distro_path/.rootfs/$1.tar.xz" "https://github.com/EXALAB/Anlinux-Resources/raw/master/Rootfs/CentOS_Stream/arm64/centos_stream-rootfs-arm64.tar.xz"
            elif [ "$hardware_machine" = "amd64" ]; then
                wget -O "$chroot_distro_path/.rootfs/$1.tar.xz" "https://github.com/EXALAB/Anlinux-Resources/raw/master/Rootfs/CentOS_Stream/amd64/centos_stream-rootfs-amd64.tar.xz"
            else
                echo "Unsupported machine hardware: $(uname -m)"
                exit
            fi
            if [ $? -ne 0 ]; then
                echo "Failed to download the CentOS Stream Rootfs."
                rm $chroot_distro_path/.rootfs/$1.tar.xz
                exit
            fi
        else
            echo "Already downloaded."
        fi

    elif [ "$1" = "void" ]; then
        echo "[1] void linux 20210218"
        echo "[2] void linux 20210316"
        echo "[3] void linux 20210930"
        echo "[4] void linux 20221001"
        echo "[5] void linux 20230628"
        echo "[6] void linux current"
        while true; do
            printf "Enter a number : "
            read number
            case "$number" in
                1) rootfs="20210218";break;;
                2) rootfs="20210316"; break;;
                3) rootfs="20210930"; break;;
                4) rootfs="20221001";break;;
                5) rootfs="20230628"; break;;
                6) rootfs="current"; break;;
                *) echo "Unknown option : $number";;
            esac
        done
        if [ ! -f "$chroot_distro_path/.rootfs/$1.tar.xz" ]; then
            if [ "$rootfs" = "current" ]; then
                wget -O "$chroot_distro_path/.rootfs/$1.tar.xz" "https://repo-default.voidlinux.org/live/$rootfs/void-$(echo $hardware_machine | sed s/arm64/aarch64/g | sed s/amd64/x86_64/g | sed s/i386/i686/g | sed s/armhf/armv7l/g)-ROOTFS-$(curl -s https://repo-default.voidlinux.org/live/current/ | grep -oE 'void-.*-ROOTFS-[0-9]+\.tar\.xz' | head -n 1 | sed -E 's/.*-ROOTFS-([0-9]+)\.tar\.xz/\1/').tar.xz"
            else
                wget -O "$chroot_distro_path/.rootfs/$1.tar.xz" "https://repo-default.voidlinux.org/live/$rootfs/void-$(echo $hardware_machine | sed s/arm64/aarch64/g | sed s/amd64/x86_64/g | sed s/i386/i686/g | sed s/armhf/armv7l/g)-ROOTFS-$rootfs.tar.xz"
            fi
            if [ $? -ne 0 ]; then
                echo "Failed to download the Void Linux Rootfs."
                rm $chroot_distro_path/.rootfs/$1.tar.xz
                exit
            fi
        else
            echo "Already downloaded."
        fi
    else
        echo "Unavailable distro: $1"
    fi
}

chroot_distro_check_if_supported() {
    echo "$1" | tr ' ' '\n' | while read -r distro; do
        if [ "$distro" = "$2" ]; then
            return 99;
        fi
    done
    if [ $? -eq 99 ]; then
        return 0;
    else
        return 1;
    fi
}

chroot_distro_find_processes_with_open_files() {
    path="$1"
    if [ "" != "$busyboxlsof" ]; then
        # busybox has own format for lsof output
        lsof | grep -F "$path" | grep -Eo '^[[:digit:]]+' | sort -n | uniq
    else
        lsof | grep -F "$path" | cut -c10- | grep -Eo '^ *[[:digit:]]+' | grep -Eo '[[:digit:]]+' | sort -n | uniq
    fi
}

chroot_distro_find_all_mount_points() {
    path="$1"
    mount | grep -F "$path" | grep -Eo '^[[:alnum:][:punct:]\/]+ on [[:alnum:][:punct:]\/]+' | grep -Eo '[[:alnum:][:punct:]\/]+$'
}

chroot_distro_find_all_loopback_mount_points() {
    path="$1"
    losetup -a | grep -F "$path" | grep -Eo '^[^:]+'
}

chroot_distro_delete() {
    supported="alpine archlinux artix debian deepin fedora manjaro openkylin opensuse pardus ubuntu void kali parrot backbox centos centos_stream"
    if ! chroot_distro_check_if_supported "$supported" "$1"; then
        echo "unavailable distro $1"
        exit 1
    fi

    archive_path="$chroot_distro_path/.rootfs/$1.tar.xz"
    if [ -f "$archive_path" ]; then
        rm "$archive_path"
    else
        echo "$1 not downloaded"
        exit 1
    fi
}

chroot_distro_output_system_mount_point_paths() {
    distro_path="$1"
    storage_paths=$(
        for file in "/storage"/*; do
            echo "$distro_path$file"
        done)
    while read -r path_to_test; do
        case "$path_to_test" in
            *"$distro_path/data/"*) echo "$path_to_test" ;;
            *"$distro_path/system/"*) echo "$path_to_test" ;;
            *"$distro_path/sdcard/"*) echo "$path_to_test" ;;
            *"$distro_path/dev/pts/"*) echo "$path_to_test" ;;
            *"$distro_path/proc/"*) echo "$path_to_test" ;;
            *"$distro_path/sys/"*) echo "$path_to_test" ;;
            *"$distro_path/dev/"*) echo "$path_to_test" ;;
            *"$distro_path/storage/"*)
                # storage check could have been just one line like the above ones but wanted to have only
                # the cases which prevents the unmount visible (ie. storage or storage/emulated are not visible)
                echo "$storage_paths" | while read -r storage_path; do
                    case "$path_to_test" in
                        *"$storage_path/"*) echo "$path_to_test" ;;
                        *) ;;
                    esac
                done
            ;;
            *) ;; # everything else, ignore
        esac
    done
}

chroot_distro_mount_system_point() {
    path_to_mount="$1"
    mount_point="$2"
    if [ ! -e "$path_to_mount" ]; then
        echo "Warning: Missing system path $path_to_mount, skipping"
        return
    fi
    if [ ! -d "$mount_point" ]; then
        if ! mkdir -p "$mount_point"; then
            echo "creating mount point $mount_point failed"
            exit 1
        fi
    fi
    if mountpoint -q "$mount_point"; then
        # nothing to do, already mounted
        return
    fi
    if ! mount --bind "$path_to_mount" "$mount_point"; then
        echo "could not mount $path_to_mount to $mount_point"
        exit 1
    fi
}

chroot_distro_mount_system_points() {
    distro_path="$1"
    use_android="$2"
    chroot_distro_mount_system_point /dev "$distro_path/dev"
    chroot_distro_mount_system_point /sys "$distro_path/sys"
    chroot_distro_mount_system_point /proc "$distro_path/proc"
    chroot_distro_mount_system_point /dev/pts "$distro_path/dev/pts"
    chroot_distro_mount_system_point /sdcard "$distro_path/sdcard"
    if [ "yes" = "$use_android" ] || [ -d "$distro_path/system" ]; then
        chroot_distro_mount_system_point /system "$distro_path/system"
    fi
    if [ "yes" = "$use_android" ] || [ -d "$distro_path/data" ]; then
        chroot_distro_mount_system_point /data "$distro_path/data"
    fi
    for file in "/storage"/*; do
        # no need for separator as separator already comes from file variable itself
        chroot_distro_mount_system_point "$file" "$distro_path$file"
    done
}

chroot_distro_unmount_system_point() {
    mount_point="$1"
    force="$2"
    if [ ! -e "$mount_point" ]; then
        # nothing to do, mount point missing
        return
    fi
    if ! mountpoint -q "$mount_point"; then
        # nothing to do, already unmounted
        return
    fi
    if [ "yes" = "$force" ]; then
        # first try to kill all processes before trying to unmount anything
        # note: close from earlier to later processes to ensure that no new worker processes are created during killing
        chroot_distro_find_processes_with_open_files "$mount_point/" | xargs -I {} kill {} > /dev/null 2>&1
        # before normal unmounts, go through all loopback devices
        # note: in reverse order in case there is loopback mount from inside the loopback mount (quite contrived case but just in case...)
        chroot_distro_find_all_loopback_mount_points "$mount_point/" | sort -r | xargs -I {} umount {} > /dev/null 2>&1
        # try to unmount everything found
        # note: using reverse sort to ensure that mounts residing deeper in the file system will be unmmounted first
        chroot_distro_find_all_mount_points "$mount_point/" | sort -r | xargs -I {} umount {} > /dev/null 2>&1
        # then hope for the best...
    fi
    # no need to check for the success as the caller will take care of that
    umount "$mount_point"
}

chroot_distro_unmount_system_points() {
    distro_path="$1"
    force="$2"
    for file in "/storage"/*; do
        # no need for separator as separator already comes from file variable itself
        chroot_distro_unmount_system_point "$distro_path$file" "$force"
    done
    chroot_distro_unmount_system_point "$distro_path/data" "$force"
    chroot_distro_unmount_system_point "$distro_path/system" "$force"
    chroot_distro_unmount_system_point "$distro_path/sdcard" "$force"
    chroot_distro_unmount_system_point "$distro_path/dev/pts" "$force"
    chroot_distro_unmount_system_point "$distro_path/proc" "$force"
    chroot_distro_unmount_system_point "$distro_path/sys" "$force"
    chroot_distro_unmount_system_point "$distro_path/dev" "$force"
}

chroot_distro_check_if_system_point_mounted() {
    mount_point="$1"
    if [ ! -e "$mount_point" ]; then
        # nothing to do, mount point missing
        return 1
    fi
    mountpoint -q "$mount_point" 2>/dev/null
    return $?
}

chroot_distro_check_if_system_points_mounted() {
    distro_path="$1"
    # shellcheck disable=SC2089
    # quotes are intentionally added
    # dev/pts is not checked as it is assumed that if dev is mounted then also pts is mounted and if dev is not mounted then pts is not mounted
    system_paths="'$distro_path/dev' '$distro_path/sys' '$distro_path/proc' '$distro_path/sdcard' '$distro_path/system' '$distro_path/data'"
    for file in "/storage"/*; do
        # no need for separator as separator already comes from file variable itself
        system_paths="$system_paths '$distro_path$file'"
    done

    # shellcheck disable=SC2090
    # shellcheck disable=SC2086
    # double quotes are intentionally omitted
    set -- $system_paths
    partial=
    quote="'"
    while [ $# -gt 0 ]
    do
        # This case shenanigan is required to ensure that if there is space in the path that the path is constructed properly
        # as we don't use quotes for set parameters. There is still possibility of somebody intentionally using path "/some' /path".
        # In this case the path will be split wrongly but then again there is likely more pressing issues if somebody gets to do that.
        case "$1" in
            *$quote)
                if [ "" = "$partial" ]; then
                    full="$1"
                else
                    full="$partial $1"
                fi
                partial=
                # strip quotes, assumes that path is 'some/path', ie. both start and end has quotes
                full="$(expr "$full" : '.\(.*\).')"

                if chroot_distro_check_if_system_point_mounted "$full"; then
                    return 0
                fi
                ;;
            *)
                if [ "" = "$partial" ]; then
                    partial="$1"
                else
                    partial="$partial $1"
                fi
                ;;
        esac
        shift
    done
    return 1
}

chroot_distro_check_archive_file_type() {
    archive_path="$1"

    # -l option would be more efficient but unfortunately busybox implementation may not support it
    if gunzip -t "$archive_path" 1>/dev/null 2>&1 ; then
        echo "gzip"
        return
    fi
    # -l option would be more efficient but unfortunately busybox implementation may not support it
    if xz -t "$archive_path" 1>/dev/null 2>&1 ; then
        echo "xz"
        return
    fi
    if tar -tf "$archive_path" 1>/dev/null 2>&1 ; then
        # either it is real tar file, or something else which isn't gunzip or xz
        echo "tar"
        return
    fi
}

chroot_distro_find_su() {
    root=$1
    su_command=""
    if [ -f "$root/bin/su" ] || [ -L "$root/bin/su" ]; then
        su_command=/bin/su
    elif [ -f "$root/usr/bin/su" ] || [ -L "$root/usr/bin/su" ]; then
        su_command=/usr/bin/su
    elif [ -f "$root/usr/local/bin/su" ] || [ -L "$root/usr/local/bin/su" ]; then
        su_command=/usr/local/bin/su
    fi
    echo "$su_command"
}

chroot_distro_jail() {
    distro_path=$1
    command=$2
    su_command=$(chroot_distro_find_su "$distro_path")

    if [ "" != "$su_command" ]; then
        (
            # try to ensure that su will do as proper login as possible to ensure consistent environment
            unset PREFIX;
            if [ "" != "$command" ]; then
                # shellcheck disable=SC1007
                PATH= chroot "$distro_path/" "$su_command" - root -c "$command"
            else
                # shellcheck disable=SC1007
                PATH= chroot "$distro_path/" "$su_command" - root
            fi
        )
        return
    fi

    echo "Warning: Missing 'su' command, can't do a proper login. Please, install 'su'"
    echo "as soon as possible to ensure consistent login environment."

    # ensure a sane PATH contents for the shell
    JAIL_PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

    JAIL_HOME=/
    if [ -d "$distro_path/root" ]; then
        JAIL_HOME=/root
    fi

    (
        # try to ensure consistent environment
        unset HISTFILE;
        unset TMPDIR;
        unset PREFIX;
        unset BOOTCLASSPATH;
        unset SYSTEMSERVERCLASSPATH;
        unset LD_LIBRARY_PATH;
        if [ "" != "$command" ]; then
            SHELL=/bin/sh HOME="$JAIL_HOME" PATH="$JAIL_PATH" chroot "$distro_path/" /bin/sh -lc "$command"
        else
            SHELL=/bin/sh HOME="$JAIL_HOME" PATH="$JAIL_PATH" chroot "$distro_path/" /bin/sh -l
        fi
    )
}

chroot_distro_install() {
    distro=$1
    use_android=$2
    supported="alpine archlinux artix debian deepin fedora manjaro openkylin opensuse pardus ubuntu void kali parrot backbox centos centos_stream"
    if ! chroot_distro_check_if_supported "$supported" "$distro"; then
        echo "unavailable distro $distro"
        exit 1
    fi

    archive_path="$chroot_distro_path/.rootfs/$distro.tar.xz"
    if [ ! -f "$archive_path" ]; then
        echo "$distro not downloaded"
        exit 1
    fi

    distro_path="$chroot_distro_path/$distro"
    if [ -d "$distro_path" ]; then
        echo "$distro already installed"
        exit 1
    fi

    common_path="$( chroot_distro_find_archive_common_path "$archive_path" )"
    # shellcheck disable=SC2181
    # we want both the output and error code, so need indirection
    if [ $? -ne 0 ]; then
        # Something went wrong with finding the archive common path
        return $?
    fi
    if [ "" = "$common_path" ]; then
        common_path="."
    fi
    rootdir="$( echo "$common_path" | cut -f1 -d/ )"
    if [ "$rootdir" != "$common_path" ]; then
        echo "Unsupported archive. rootfs archive is expected to have only at most one subdirectory before the actual content."
        exit 1
    fi
    archive_type=${archive_type-$(chroot_distro_check_archive_file_type "$archive_path")}
    if [ "" = "$archive_type" ]; then
        echo "Error: unsupported or corrupt archive"
        exit 5
    fi
    if [ "." = "$rootdir" ]; then
        mkdir "$distro_path"
        if ! tar -xf "$archive_path" -C "$distro_path/"; then
            echo "Error: Unpacking the archive failed"
            exit 5
        fi
    else
        tar -xf "$archive_path" -C "$chroot_distro_path/"
        tar_status=$?
        if [ $tar_status -ne 0 ] && [ ! -e "$chroot_distro_path/$rootdir" ]; then
            # can bail out early as no files were unpacked
            echo "Error: Unpacking the archive failed"
            exit 5
        fi
        mv "$chroot_distro_path/$rootdir" "$distro_path"
        if [ $tar_status -ne 0 ]; then
            # can bail out only when the environment is in semi consistent state
            echo "Error: Unpacking the archive failed"
            exit 5
        fi
    fi

    chroot_distro_mount_system_points "$distro_path" "$use_android"

    resolvconf="$distro_path"/etc/resolv.conf
    if [ -L "$resolvconf" ] && [ ! -f "$resolvconf" ]; then
        # broken link
        rm "$resolvconf"
    fi
    echo "nameserver 8.8.8.8" > "$resolvconf"
    echo "127.0.0.1 localhost" > "$distro_path"/etc/hosts
    chroot "$distro_path" /sbin/groupadd -g 3003 aid_inet 2>/dev/null
    chroot "$distro_path" /sbin/groupadd -g 3004 aid_net_raw 2>/dev/null
    chroot "$distro_path" /sbin/groupadd -g 1003 aid_graphics 2>/dev/null
    chroot "$distro_path" /sbin/usermod -g 3003 -G 3003,3004 -a _apt 2>/dev/null
    chroot "$distro_path" /sbin/usermod -G 3003 -a root 2>/dev/null
    chroot "$distro_path" /bin/ln -sf /usr/share/zoneinfo/Asia/Taipei /etc/localtime 2>/dev/null
    chroot "$distro_path" /sbin/locale-gen en_US.UTF-8 2>/dev/null
    chroot_distro_jail "$distro_path"
}

chroot_distro_list_unmount_issues() {
    distro_path=$1
    command=$2
    mode=$3
    force=$4
    mounts=$5
    loopbacks=$6
    open_files=$7

    unset maybe_more
    if [ "all" != "$mode" ]; then
        maybe_more=true
    fi
    # note: if there is still system mount points mounted without a valid reason, please create a bug report so that it can be investigated
    echo 'distro is potentially running - if needed shutdown the distro, and unmount mounted folders'
    echo
    if [ "yes" != "$force" ]; then
        echo "You can try running $command again with -f(--force) option to automatically close/unmount files/folders mentioned below."
        echo 'Please note, that using --force option may close more programs than intended, so use it with care.'
    fi
    echo
    echo "open files under $distro_path${maybe_more+ (which affects unmounting, there may be more)}:"
    if [ "" = "$lsofpath" ]; then
        echo "Warning: supported lsof not found, run \`lsof | grep -F '$distro_path/'\` manually"
    fi
    echo "${open_files:-Not found}"
    echo "end of open files"
    echo
    echo "mount points under $distro_path${maybe_more+ (which affects unmounting, there may be more)}:"
    echo "${mounts:-Not found}"
    echo "end of mount points"
    echo
    echo "loopback devices under $distro_path${maybe_more+ (which affects unmounting, there may be more)}:"
    echo "${loopbacks:-Not found}"
    echo "end of loopback devices"
    echo
    echo "If there is no open files, mount points ${maybe_more-(outside of system mount points) }or loopback devices,"
    echo "then check for anonymous inodes and inotify watches"
}

chroot_distro_uninstall() {
    supported="alpine archlinux artix debian deepin fedora manjaro openkylin opensuse pardus ubuntu void kali parrot backbox centos centos_stream"
    if ! chroot_distro_check_if_supported "$supported" "$1"; then
        echo "unavailable distro $1"
        exit 1
    fi

    distro_path="$chroot_distro_path/$1"
    force=$2
    command=$3

    if [ -d "$distro_path" ]; then
        if [ "yes" = "$force" ]; then
            # first try to kill all processes before trying to unmount anything
            # note: close from earlier to later processes to ensure that no new worker processes are created during killing
            chroot_distro_find_processes_with_open_files "$distro_path/" | xargs -I {} kill {} > /dev/null 2>&1
            # before normal unmounts, go through all loopback devices
            # note: in reverse order in case there is loopback mount from inside the loopback mount (quite contrived case but just in case...)
            chroot_distro_find_all_loopback_mount_points "$distro_path/" | sort -r | xargs -I {} umount {} > /dev/null 2>&1
            # try to unmount everything found
            # note: using reverse sort to ensure that mounts residing deeper in the file system will be unmmounted first
            chroot_distro_find_all_mount_points "$distro_path/" | sort -r | xargs -I {} umount {} > /dev/null 2>&1
            # then hope for the best...
        fi
        chroot_distro_unmount_system_points "$distro_path" no
        mounts=$(mount | grep -F "$distro_path")
        loopbacks=$(losetup -a | grep -F "$distro_path")
        open_files=$(lsof | grep -F "$distro_path")
        if [ "" != "$mounts" ] || [ "" != "$loopbacks" ] || [ "" != "$open_files" ]; then
            chroot_distro_list_unmount_issues "$distro_path" "$command" 'all' "$force" "$mounts" "$loopbacks" "$open_files"
            exit 1
        fi

        # when reaching this point it is assumed that uninstalling the distro is ok, no irreversible changes to distro before this line

        # ensure that there is no symbolic links before nuking the rootfs, symbolic links may point outside of rootfs when outside of the chroot
        find "$distro_path" -type l -exec unlink {} \;
        rm -rf "$distro_path"
    else
        echo "$1 not installed"
        exit 1
    fi
}

chroot_distro_backup() {
    distro=$1
    custom_path=$2
    supported="alpine archlinux artix debian deepin fedora manjaro openkylin opensuse pardus ubuntu void kali parrot backbox centos centos_stream"
    if ! chroot_distro_check_if_supported "$supported" "$distro"; then
        echo "unavailable distro $distro"
        exit 1
    fi

    distro_path="$chroot_distro_path/$1"
    if [ ! -d "$distro_path" ]; then
        echo "distro not installed, no need to backup"
        exit
    fi

    # Check system mount points, to ensure that we are not backing up a running system.
    # If system mount points are mounted then those will be backed up as well but in most
    # cases those are not wanted, as the restore will not work properly (mounts will shadow
    # the content). If data/sdcard etc. are needed to backup then it is better to do it
    # with different tool (for example twrp) and/or from inside the chroot
    if chroot_distro_check_if_system_points_mounted "$distro_path"; then
        echo "distro is potentially running - if needed shutdown the distro, and unmount system mount points ($script unmount $1) before proceeding"
        exit
    fi

    open_file_count=$(lsof | grep -Fc "$distro_path")
    if [ "" = "$lsofpath" ]; then
        echo "Warning: supported lsof not found, open files and/or programs currently running in jail will not be found."
        echo "In the case of errors run \`lsof | grep -F '$distro_path/'\` manually"
    elif [ "0" != "$open_file_count" ]; then
        echo "Warning: Open files detected, backup may fail (at least partially)"
    fi

    # mounted volumes should be backed up outside of this script as it may not work as intended
    # (same reasons as system mount points)
    mounts=$(mount | grep -F "$distro_path")
    loopbacks=$(losetup -a | grep -F "$distro_path")
    if [ "0" != "$mounts" ] || [ "0" != "$loopbacks" ]; then
        echo "distro is potentially running - if needed shutdown the distro, and unmount mounted folders"
        echo
        echo "To automatically unmount mount points mentioned below, run \`$script unmount -a $1\`"
        echo
        echo "mount points under $distro_path:"
        echo "${mounts:-Not found}"
        echo "end of mount points"
        echo
        echo "loopback devices under $distro_path:"
        echo "${loopbacks:-Not found}"
        echo "end of loopback devices"
        exit 1
    fi

    if [ "" = "$custom_path" ]; then
        backup_path="$chroot_distro_path/.backup/$1.tar.xz"
        if [ -f "$backup_path" ]; then
            echo "backup already exist, unbackup and try agin"
            exit 1
        fi
        (
            cd "$chroot_distro_path" || exit 1;
            tar -caf "$backup_path" "$distro"
        )
        # shellcheck disable=SC2181
        if [ $? -ne 0 ]; then
            echo "Error: creating the backup failed"
            exit 5
        fi
    else
        absolute_custom_path="$custom_path"
        if [ "$custom_path" = "${custom_path#/}" ]; then
            # can not have a relative path as current directory will change
            absolute_custom_path="$PWD/$custom_path"
        fi
        (
            cd "$chroot_distro_path" || exit 1;
            tar -caf "$absolute_custom_path" "$distro"
        )
        # shellcheck disable=SC2181
        if [ $? -ne 0 ]; then
            echo "Error: creating the backup failed"
            exit 5
        fi
    fi
}

chroot_distro_find_archive_common_path() {
    archive_path=$1
    archive_type=${archive_type-$(chroot_distro_check_archive_file_type "$archive_path")}
    if [ "" = "$archive_type" ]; then
        echo "Error: unsupported or corrupt archive" >&2
        exit 5
    fi
    paths_to_check="$(tar -tf "$archive_path" 2>/dev/null)"

    i=1
    prev_path=

    while [ $i -lt 100 ]
    do
        path=$(echo "$paths_to_check" | cut -f1-"$i" -d/ | uniq -u)
        if [ -z "$path" ]; then
            prev_path=$(echo "$paths_to_check" | cut -f1-"$i" -d/ | uniq)
        else
            echo "$prev_path"
            break
        fi
        i=$((i+1))
    done
}

chroot_distro_unbackup() {
    supported="alpine archlinux artix debian deepin fedora manjaro openkylin opensuse pardus ubuntu void kali parrot backbox centos centos_stream"
    if ! chroot_distro_check_if_supported "$supported" "$1"; then
        echo "unavailable distro $1"
        exit 1
    fi

    backup_path="$chroot_distro_path/.backup/$1.tar.xz"
    if [ -f "$backup_path" ]; then
        rm "$backup_path"
    else
        echo "backup not found $1"
        exit 1
    fi
}

chroot_distro_restore() {
    distro="$1"
    custom_backup_path="$2"
    restore_defaults="$3"
    force="$4"
    supported="alpine archlinux artix debian deepin fedora manjaro openkylin opensuse pardus ubuntu void kali parrot backbox centos centos_stream"
    if ! chroot_distro_check_if_supported "$supported" "$distro"; then
        echo "unavailable distro $distro"
        exit 1
    fi

    distro_path="$chroot_distro_path/$distro"
    if [ -d "$distro_path" ]; then
        echo "distro already installed , uninstall and try again"
        exit 1
    fi

    if [ "" = "$custom_backup_path" ]; then
        backup_path="$chroot_distro_path/.backup/$1.tar.xz"
    else
        absolute_backup_path="$custom_backup_path"
        if [ "$custom_backup_path" = "${custom_backup_path#/}" ]; then
            # can not have a relative path as current directory may and will change
            absolute_backup_path="$PWD/$custom_backup_path"
        fi
        backup_path="$absolute_backup_path"
    fi

    if [ ! -f "$backup_path" ]; then
        echo "backup not found"
        exit 1
    fi

    common_path="$(chroot_distro_find_archive_common_path "$backup_path")"
    # shellcheck disable=SC2181
    # we want both the output and error code, so need indirection
    if [ $? -ne 0 ]; then
        # Something went wrong with finding the archive common path
        return $?
    fi
    if [ "" = "$common_path" ]; then
        common_path="."
    fi
    rootdir="$( echo "$common_path" | cut -f1 -d/ )"

    archive_type=${archive_type-$(chroot_distro_check_archive_file_type "$backup_path")}
    if [ "" = "$archive_type" ]; then
        echo "Error: unsupported or corrupt archive"
        exit 5
    fi

    if [ "." = "$rootdir" ]; then
        # backup has relative path, restoring is not a problem
        mkdir "$distro_path"
        tar -xf "$backup_path" -C "$distro_path/"
        # shellcheck disable=SC2181
        if [ $? -ne 0 ]; then
            echo "Error: Unpacking the archive failed"
            exit 5
        fi
    elif [ "data" = "$rootdir" ] && [ "yes" = "$force" ]; then
        # Uses old format of backups. Accept only if user has reviewed the content as the backup needs to be
        # applied from root directory, potentially rendering the system unstable and/or be compromised.
        # Also, backup may contain files which will not be visible from running system and will potentially
        # fill the internal storage. There is also possibility of using wrong backup.
        (
            cd /
            tar -xf "$backup_path"
        )
        # shellcheck disable=SC2181
        if [ $? -ne 0 ]; then
            echo "Error: Unpacking the archive failed"
            exit 5
        fi
    elif [ "data" = "$rootdir" ]; then
        echo "Will restore from root directory, review the contents and use --force."
        echo "Warning: Old style backup. May contain file backups from sdcard and other system mount points."
        echo "Restore may fail if not enough space on internal storage, and restored files from system mount"
        echo "points will be shadowed by system mounts."
        if [ "/$common_path" != "$distro_path" ]; then
            echo "Warning: Backup may be for different distro:"
            echo "- expected common denominator path: $distro_path"
            echo "- archive had following common denominator path: /$common_path"
        fi
        exit 4
    elif [ "$distro" = "$rootdir" ]; then
        # new format backups
        (
            cd "$chroot_distro_path" || exit 1;
            tar -xf "$backup_path"
        )
        # shellcheck disable=SC2181
        if [ $? -ne 0 ]; then
            echo "Error: Unpacking the archive failed"
            exit 5
        fi
    else
        echo "Backup may be for wrong distro (root directory $rootdir), review the backup before proceeding"
        exit 4
    fi

    chroot_distro_mount_system_points "$distro_path" no

    if [ "yes" = "$restore_defaults" ]; then
        resolvconf="$distro_path"/etc/resolv.conf
        if [ -L "$resolvconf" ] && [ ! -f "$resolvconf" ]; then
            # broken link
            rm "$resolvconf"
        fi
        echo "nameserver 8.8.8.8" > "$resolvconf"
        echo "127.0.0.1 localhost" > "$distro_path"/etc/hosts
        chroot "$distro_path" /sbin/groupadd -g 3003 aid_inet 2>/dev/null
        chroot "$distro_path" /sbin/groupadd -g 3004 aid_net_raw 2>/dev/null
        chroot "$distro_path" /sbin/groupadd -g 1003 aid_graphics 2>/dev/null
        chroot "$distro_path" /sbin/usermod -g 3003 -G 3003,3004 -a _apt 2>/dev/null
        chroot "$distro_path" /sbin/usermod -G 3003 -a root 2>/dev/null
        chroot "$distro_path" /bin/ln -sf /usr/share/zoneinfo/Asia/Taipei /etc/localtime 2>/dev/null
        chroot "$distro_path" /sbin/locale-gen en_US.UTF-8 2>/dev/null
    fi
    chroot_distro_jail "$distro_path"
}

chroot_distro_unmount() {
    distro="$1"
    force="$2"
    all="$3"
    supported="alpine archlinux artix debian deepin fedora manjaro openkylin opensuse pardus ubuntu void kali parrot backbox centos centos_stream"
    if ! chroot_distro_check_if_supported "$supported" "$distro"; then
        echo "unavailable distro $distro"
        exit 1
    fi

    distro_path="$chroot_distro_path/$distro"
    if [ ! -d "$distro_path" ]; then
        echo "$distro not installed"
        exit 1
    fi

    if [ "yes" = "$all" ]; then
        if [ "yes" = "$force" ]; then
            # first try to kill all processes before trying to unmount anything
            # note: close from earlier to later processes to ensure that no new worker processes are created during killing
            chroot_distro_find_processes_with_open_files "$distro_path/" | xargs -I {} kill {} > /dev/null 2>&1
        fi
        # before normal unmounts, go through all loopback devices
        # note: in reverse order in case there is loopback mount from inside the loopback mount (quite contrived case but just in case...)
        chroot_distro_find_all_loopback_mount_points "$distro_path/" | sort -r | xargs -I {} umount {} > /dev/null 2>&1
        # try to unmount everything found
        # note: using reverse sort to ensure that mounts residing deeper in the file system will be unmmounted first
        chroot_distro_find_all_mount_points "$distro_path/" | sort -r | xargs -I {} umount {} > /dev/null 2>&1
    else
        chroot_distro_unmount_system_points "$distro_path" "$force"
    fi

    if [ "yes" = "$all" ]; then
        mounts=$(mount | grep -F "$distro_path")
        loopbacks=$(losetup -a | grep -F "$distro_path")
        open_files=$(lsof | grep -F "$distro_path")
        # as all mount points are being unmounted, no need to test for system mount points separately
        system_mount_points_mounted=1
        mode=all
    else
        mounts=$(mount | grep -F "$distro_path" | chroot_distro_output_system_mount_point_paths "$distro_path")
        loopbacks=$(losetup -a | grep -F "$distro_path" | chroot_distro_output_system_mount_point_paths "$distro_path")
        open_files=$(lsof | grep -F "$distro_path" | chroot_distro_output_system_mount_point_paths "$distro_path")
        chroot_distro_check_if_system_points_mounted "$distro_path"
        system_mount_points_mounted=$?
        mode=system
    fi
    if [ "" != "$mounts" ] || [ "" != "$loopbacks" ] || [ "" != "$open_files" ] || [ "0" = "$system_mount_points_mounted" ]; then
        chroot_distro_list_unmount_issues "$distro_path" 'unmount' "$mode" "$force" "$mounts" "$loopbacks" "$open_files"
        exit 1
    fi
}

chroot_distro_command() {
    supported="alpine archlinux artix debian deepin fedora manjaro openkylin opensuse pardus ubuntu void kali parrot backbox centos centos_stream"
    if ! chroot_distro_check_if_supported "$supported" "$1"; then
        echo "unavailable distro $1"
        exit 1
    fi

    command="$2"

    distro_path="$chroot_distro_path/$1"
    if [ ! -d "$distro_path" ]; then
        echo "$1 not installed"
        exit 1
    fi

    chroot_distro_mount_system_points "$distro_path" no

    chroot_distro_jail "$distro_path" "$command"
}

chroot_distro_login() {
    supported="alpine archlinux artix debian deepin fedora manjaro openkylin opensuse pardus ubuntu void kali parrot backbox centos centos_stream"
    if ! chroot_distro_check_if_supported "$supported" "$1"; then
        echo "unavailable distro $1"
        exit 1
    fi

    distro_path="$chroot_distro_path/$1"
    if [ ! -d "$distro_path" ]; then
        echo "$1 not installed"
        exit 1
    fi

    chroot_distro_mount_system_points "$distro_path" no

    chroot_distro_jail "$distro_path"
}

chroot_distro_invalid_parameters() {
    echo "$script - $1"
    echo "try '$script help' for more information"
    exit 2
}

chroot_distro_user_check_parameters() {
    chroot_distro_invalid_parameters "unknonwn parameters"
}

chroot_distro_missing_distro() {
    chroot_distro_invalid_parameters "misssing distro"
}

if [ $# -eq 0 ]; then
    chroot_distro_help
    exit
fi

command=$1
shift

if [ "$command" = "help" ]; then
    PARSED=$(getopt --options= --longoptions= --name "$0" -- "$@") || exit 2
    chroot_distro_help
elif [ "$command" = "list" ]; then
    PARSED=$(getopt --options= --longoptions= --name "$0" -- "$@") || exit 2
    eval set -- "$PARSED"
    while true; do
        case "$1" in
            --)
                shift
                break
                ;;
            *)
                echo "Programming error"
                exit 3
                ;;
        esac
    done
    if [ $# -ne 0 ]; then
        chroot_distro_user_check_parameters
    fi
    chroot_distro_list
elif [ "$command" = "download" ]; then
    PARSED=$(getopt --options= --longoptions= --name "$0" -- "$@") || exit 2
    eval set -- "$PARSED"
    while true; do
        case "$1" in
            --)
                shift
                break
                ;;
            *)
                echo "Programming error"
                exit 3
                ;;
        esac
    done
    if [ $# -eq 0 ]; then
        chroot_distro_missing_distro
    elif [ $# -ne 1 ]; then
        chroot_distro_user_check_parameters
    fi
    chroot_distro_warn_if_unsupported_busybox
    chroot_distro_download "$1"
elif [ "$command" = "redownload" ]; then
    PARSED=$(getopt --options= --longoptions= --name "$0" -- "$@") || exit 2
    eval set -- "$PARSED"
    while true; do
        case "$1" in
            --)
                shift
                break
                ;;
            *)
                echo "Programming error"
                exit 3
                ;;
        esac
    done
    if [ $# -eq 0 ]; then
        chroot_distro_missing_distro
    elif [ $# -ne 1 ]; then
        chroot_distro_user_check_parameters
    fi
    chroot_distro_download "$1"
elif [ "$command" = "delete" ]; then
    PARSED=$(getopt --options= --longoptions= --name "$0" -- "$@") || exit 2
    eval set -- "$PARSED"
    while true; do
        case "$1" in
            --)
                shift
                break
                ;;
            *)
                echo "Programming error"
                exit 3
                ;;
        esac
    done
    if [ $# -eq 0 ]; then
        chroot_distro_missing_distro
    elif [ $# -ne 1 ]; then
        chroot_distro_user_check_parameters
    fi
    chroot_distro_delete "$1"
elif [ "$command" = "install" ]; then
    PARSED=$(getopt --options=a --longoptions=android --name "$0" -- "$@") || exit 2
    eval set -- "$PARSED"
    android=no
    while true; do
        case "$1" in
            -a|--android)
                android=yes
                shift
                ;;
            --)
                shift
                break
                ;;
            *)
                echo "Programming error"
                exit 3
                ;;
        esac
    done
    if [ $# -eq 0 ]; then
        chroot_distro_missing_distro
    elif [ $# -ne 1 ]; then
        chroot_distro_user_check_parameters
    fi
    chroot_distro_warn_if_unsupported_busybox
    chroot_distro_install "$1" "$android"
elif [ "$command" = "uninstall" ]; then
    PARSED=$(getopt --options=f --longoptions=force --name "$0" -- "$@") || exit 2
    eval set -- "$PARSED"
    force=no
    while true; do
        case "$1" in
            -f|--force)
                force=yes
                shift
                ;;
            --)
                shift
                break
                ;;
            *)
                echo "Programming error"
                exit 3
                ;;
        esac
    done
    if [ $# -eq 0 ]; then
        chroot_distro_missing_distro
    elif [ $# -ne 1 ]; then
        chroot_distro_user_check_parameters
    fi
    chroot_distro_uninstall "$1" "$force" "$command"
elif [ "$command" = "reinstall" ]; then
    OPTS=af LONGOPTS=android,force
    PARSED=$(getopt --options=$OPTS --longoptions=$LONGOPTS --name "$0" -- "$@") || exit 2
    eval set -- "$PARSED"
    android=no
    force=no
    while true; do
        case "$1" in
            -a|--android)
                android=yes
                shift
                ;;
            -f|--force)
                force=yes
                shift
                ;;
            --)
                shift
                break
                ;;
            *)
                echo "Programming error"
                exit 3
                ;;
        esac
    done
    if [ $# -eq 0 ]; then
        chroot_distro_missing_distro
    elif [ $# -ne 1 ]; then
        chroot_distro_user_check_parameters
    fi
    chroot_distro_uninstall "$1" "$force" "$command"
    chroot_distro_install "$1" "$android"
elif [ "$command" = "backup" ]; then
    PARSED=$(getopt --options= --longoptions= --name "$0" -- "$@") || exit 2
    eval set -- "$PARSED"
    while true; do
        case "$1" in
            --)
                shift
                break
                ;;
            *)
                echo "Programming error"
                exit 3
                ;;
        esac
    done
    if [ $# -eq 0 ]; then
        chroot_distro_missing_distro
    elif [ $# -gt 2 ]; then
        chroot_distro_user_check_parameters
    fi
    chroot_distro_backup "$1" "$2"
elif [ "$command" = "unbackup" ]; then
    PARSED=$(getopt --options= --longoptions= --name "$0" -- "$@") || exit 2
    eval set -- "$PARSED"
    while true; do
        case "$1" in
            --)
                shift
                break
                ;;
            *)
                echo "Programming error"
                exit 3
                ;;
        esac
    done
    if [ $# -eq 0 ]; then
        chroot_distro_missing_distro
    elif [ $# -ne 1 ]; then
        chroot_distro_user_check_parameters
    fi
    chroot_distro_unbackup "$1"
elif [ "$command" = "restore" ]; then
    OPTS=d LONGOPTS=default,force
    PARSED=$(getopt --options=$OPTS --longoptions=$LONGOPTS --name "$0" -- "$@") || exit 2
    eval set -- "$PARSED"
    restore_defaults=no
    force=no
    while true; do
        case "$1" in
            -d|--default)
                restore_defaults=yes
                shift
                ;;
            --force)
                force=yes
                shift
                ;;
            --)
                shift
                break
                ;;
            *)
                echo "Programming error"
                exit 3
                ;;
        esac
    done
    if [ $# -eq 0 ]; then
        chroot_distro_missing_distro
    elif [ $# -gt 2 ]; then
        chroot_distro_user_check_parameters
    fi
    chroot_distro_restore "$1" "$2" "$restore_defaults" "$force"
elif [ "$command" = "command" ]; then
    PARSED=$(getopt --options= --longoptions= --name "$0" -- "$@") || exit 2
    eval set -- "$PARSED"
    while true; do
        case "$1" in
            --)
                shift
                break
                ;;
            *)
                echo "Programming error"
                exit 3
                ;;
        esac
    done
    if [ $# -eq 0 ]; then
        chroot_distro_missing_distro
    elif [ $# -eq 1 ]; then
        chroot_distro_invalid_parameters "program missing"
    elif [ $# -ne 2 ]; then
        chroot_distro_user_check_parameters
    fi
    chroot_distro_command "$1" "$2"
elif [ "$command" = "login" ]; then
    PARSED=$(getopt --options= --longoptions= --name "$0" -- "$@") || exit 2
    eval set -- "$PARSED"
    while true; do
        case "$1" in
            --)
                shift
                break
                ;;
            *)
                echo "Programming error"
                exit 3
                ;;
        esac
    done
    if [ $# -eq 0 ]; then
        chroot_distro_missing_distro
    elif [ $# -ne 1 ]; then
        chroot_distro_user_check_parameters
    fi
    chroot_distro_login "$1"
elif [ "$command" = "unmount" ]; then
    PARSED=$(getopt --options=fa --longoptions=force,all --name "$0" -- "$@") || exit 2
    eval set -- "$PARSED"
    force=no
    all=no
    while true; do
        case "$1" in
            -f|--force)
                force=yes
                shift
                ;;
            -a|--all)
                all=yes
                shift
                ;;
            --)
                shift
                break
                ;;
            *)
                echo "Programming error"
                exit 3
                ;;
        esac
    done
    if [ $# -eq 0 ]; then
        chroot_distro_missing_distro
    elif [ $# -ne 1 ]; then
        chroot_distro_user_check_parameters
    fi
    chroot_distro_unmount "$1" "$force" "$all"
else
    chroot_distro_invalid_parameters "invalid command $command"
fi
