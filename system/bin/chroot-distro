#!/system/bin/sh
#
# Copyright 2024 Yasser Null
#
# Code is licensed under terms of GNU GPL v3, see LICENSE file
# for the full terms.

if [ ! -z "${chroot_distro_log+x}" ]; then
  set -e
  set -x
  trap 'echo "Error at line $LINENO"' ERR
fi

chroot_distro_path="/data/local/chroot-distro"
script=$(basename "$0")

if [ "$(id -u)" -ne 0 ]; then
    echo "Root access required."
    exit 1
fi

machine=$(uname -m)
case "$(uname -m)" in
    aarch64|arm64) hardware_machine="arm64" ;;
    arm|armel|armhf|armhfp|armv7|armv7l|armv7a|armv8l) hardware_machine="armhf" ;;
    386|i386|i686|x86) hardware_machine="i386" ;;
    amd64|x86_64) hardware_machine="amd64" ;;
    *) echo "Unsupported machine hardware: $(uname -m)"; exit 1 ;;
esac
unset machine

supported_distros="alpine archlinux artix debian deepin fedora manjaro openkylin opensuse pardus ubuntu void kali parrot backbox centos centos_stream rocky adelie chimera gentoo"

check_env=''
if [ $# -ge 1 ] && [ "env" = "$1" ]; then
    check_env=true
fi

if [ "" = "$check_env" ]; then
    : # do nothing
elif [ -e /data/adb/modules/chroot-distro ]; then
    echo "Script: $0"
    hash=$(md5sum "$0" | cut -d " " -f1)
    if cmp -s "$0" /data/adb/modules/chroot-distro/system/bin/chroot-distro; then
        (
            module_prop=$(cat /data/adb/modules/chroot-distro/module.prop)
            echo "$module_prop" | while read -r row; do
                field=$(echo "$row" | cut -d "=" -f 1 )
                value=$(echo "$row" | cut -d "=" -f 2 )
                case "$field" in
                    version) echo "Version: $value" ;;
                    versionCode) echo "Versioncode: $value" ;;
                esac
            done
            echo "md5 hash: $hash"
        )
    else
        echo "Not matching installed version, md5 hash: $hash"
    fi
else
    echo "Script: $0"
    echo "Unknown version, md5 hash: $(md5sum "$0" | cut -d " " -f1)"
fi

if [ "" != "$check_env" ]; then
    echo "Toybox version: $(toybox --version)"
fi

busyboxpath="$(command -v busybox 2> /dev/null || true)"
if [ -z "$busyboxpath" ]; then
    busyboxpath=''
    if [ -e /data/adb ]; then
        # try harder... -- thanks for the pointer, @osm0sis
        if [ "" != "$check_env" ]; then
            echo 'Checking for hidden Busyboxes'
        fi
        for possiblepath in /data/adb/modules/busybox-ndk/system/*/busybox /data/adb/magisk/busybox /data/adb/ksu/bin/busybox /data/adb/ap/bin/busybox; do
            if [ -f "$possiblepath" ]; then
                busyboxpath="$possiblepath"
                break
            fi
        done;
    fi
    if [ "" = "$check_env" ] && [ "" = "$busyboxpath" ]; then
        echo "busybox not found, install Busybox for Android NDK and try again"
        echo "Run '$script env' for extra information"
        exit 1
    fi
fi

if [ "" != "$check_env" ]; then
    echo "busybox => '$busyboxpath'"
    if [ "" != "$busyboxpath" ]; then
        echo "Busybox version: $($busyboxpath | head -n1)"
    fi
fi

unsupported_busybox=''
case "$busyboxpath" in
    /bin/*) ;; # assume that it is ok (either old android, or linux), nothing to do
    /system/*)
        ndk_path=/system/xbin/busybox
        if [ "$busyboxpath" != "$ndk_path" ] && [ -e "$ndk_path" ]; then
            # force use of Busybox for Android NDK in the case there is conflicting versions
            if [ "" != "$check_env" ]; then
                echo "Forcing Busybox path from '$busyboxpath' to '$ndk_path'"
                echo "Forced Busybox version: $($ndk_path | head -n1)"
            fi
            busyboxpath="$ndk_path"
        fi
    ;;
    /data/adb/modules/busybox-ndk/system/*) ;; # hidden Busybox for Android NDK, nothing to do
    /data/adb/magisk/*) unsupported_busybox=true ;; # Magisk without Busybox for Android NDK installed
    /usr/bin/*) ;; # running linux, assume that all is ok, nothing to do
    /data/adb/ksu/bin/*) unsupported_busybox=true ;; # KernelSU without Busybox for Android NDK installed
    /data/adb/ap/bin/*) unsupported_busybox=true ;; # APatch without Busybox for Android NDK installed
    *)
        if [ "" = "$check_env" ]; then
            echo "busybox not found from the expected path, ensure that Busybox for Android NDK has been installed and try again"
            echo "Run '$script env' for extra information"
            exit 1
        fi
    ;;
esac

busyboxdir="$(dirname "$busyboxpath")"
can_use_busyboxdir=true
if [ "" = "$busyboxpath" ]; then
    # not found
    can_use_busyboxdir=''
elif [ "/system/bin" = "$busyboxdir" ]; then
    # would use Toybox version always, skip
    can_use_busyboxdir=''
elif [ "/usr/bin" = "$busyboxdir" ]; then
    # would use full/normal chroot command, skip to ensure consistent test environment
    can_use_busyboxdir=''
fi
if [ "" != "$can_use_busyboxdir" ] &&  [ -e "$busyboxdir"/chroot ]; then
    # Use chroot from the expected Busybox
    chrootpath="$(dirname "$busyboxpath")"/chroot
elif [ -e /system/xbin/chroot ]; then
    # Use a Busybox version
    chrootpath=/system/xbin/chroot
elif [ -e /system/bin/chroot ]; then
    # Fall back to Toybox version
    chrootpath=/system/bin/chroot
else
    # don't want to use a random chroot to ensure it doesn't affect the jail
    chrootpath=''
fi
unset can_use_busyboxdir
unset busyboxdir

if [ "" = "$check_env" ] && [ "" = "$chrootpath" ]; then
    echo "chroot not found from the expected path, ensure that Busybox for Android NDK has been installed and try again"
    echo "Run '$script env' for extra information"
    exit 1
fi

busyboxlsofcaller=''
busyboxlsof=''
if [ "" != "$busyboxpath" ] && "$busyboxpath" lsof > /dev/null 2>&1 || true; then
    # prefer the version provided by the found busybox binary
    busyboxlsofcaller=true
    busyboxlsof=true
    lsofpath='busybox lsof'
elif [ -e /system/xbin/lsof ]; then
    # busybox version
    lsofpath=/system/xbin/lsof
    busyboxlsof=true
elif [ -e /system/bin/lsof ]; then
    # toybox version
    lsofpath=/system/bin/lsof
else
    # don't want to use random lsof as it may not work (or has different output)
    # in this case user has to manually run the command
    lsofpath=''
fi

# ensure that the expected version of busybox is used
busybox() { "$busyboxpath" "$@"; }

# Toybox uname does not support -p
uname() {
    if [ "" != "$busyboxpath" ]; then
        busybox uname "$@";
    else
        # fall back to defaults to ensure at least some output
        uname -a
    fi
}

# ensure that busybox version of getopt is used
getopt() { busybox getopt "$@"; }

# ensure that busybox version of tar is used
tar() { busybox tar "$@"; }

# ensure that busybox version of wget is used
wget() { busybox wget "$@"; }

# ensure that correct version of chroot is used
chroot() { "$chrootpath" "$@"; }

lsof() {
    if [ "" != "$busyboxlsofcaller" ]; then
        busybox lsof
    elif [ "" = "$lsofpath" ]; then
        # lsof is optional, no output
        :
    else
        "$lsofpath";
    fi
}

if [ "" != "$check_env" ]; then
    echo "chroot => '$chrootpath'"
    if [ "" = "$chrootpath" ]; then
        echo "chroot found in PATH (but not used) => '$(command -v chroot 2> /dev/null)'"
    fi
    echo "lsof => '$lsofpath'"
    if [ "" = "$lsofpath" ]; then
        echo "lsof found in PATH (but not used) => '$(command -v lsof 2> /dev/null)'"
    fi
    if [ ! -e /data/adb ]; then
        echo 'Could not determine the type of root solution installed'
    elif [ -e /data/adb/magisk ]; then
        case "$hardware_machine" in
            *64)
                if [ -e /data/adb/magisk/magisk64 ]; then
                    magiskbin=/data/adb/magisk/magisk64
                elif [ -e /data/adb/magisk/magisk ]; then
                    magiskbin=/data/adb/magisk/magisk
                fi
                if [ "" != "$magiskbin" ]; then
                    magisk_version=$($magiskbin -v)
                else
                    magisk_version=Unknown
                fi
            ;;
            *)
                if [ -e /data/adb/magisk/magisk32 ]; then
                    magiskbin=/data/adb/magisk/magisk32
                elif [ -e /data/adb/magisk/magisk ]; then
                    magiskbin=/data/adb/magisk/magisk
                fi
                if [ "" != "$magiskbin" ]; then
                    magisk_version=$($magiskbin -v)
                else
                    magisk_version=Unknown
                fi
            ;;
        esac
        echo "Magisk installed ($magisk_version)"
    elif [ -e /data/adb/ksu ]; then
        # would be nice if the version information could be provided, patches welcome
        echo "KernelSU installed (Unknown)"
    elif [ -e /data/adb/ap ]; then
        # Verify the APatch daemon executable exists
        if [ -e /data/adb/ap/bin/apd ]; then
            # Set path to APatch daemon and get its version
            apatchbin=/data/adb/ap/bin/apd
            binary_version=$("$apatchbin" -V | awk '{print $2}')

            # I can't find any method or way, with no documentation whatsoever to get the kernel patch version
            # So I had to do it in a ughh fucking crude way by getting the value from the log and calculating it
            if [ -e /data/adb/ap/log/dmesg.log ]; then
                # Extract the KernelPatch version hex value from log (e.g., "b01")
                # $6 refers to the 6th field in the log line "KP KernelPatch Version: b01"
                kp_version=$(grep "KP KernelPatch Version:" /data/adb/ap/log/dmesg.log | awk '{print $6}')

                # Check if we successfully got a version number
                if [ -z "$kp_version" ]; then
                    apatch_version="Unknown"
                else
                    # Clean up the hex value:
                    # - Remove '0x' prefix if present using sed
                    # - Convert to lowercase for consistency
                    clean_hex=$(echo "$kp_version" | sed 's/^0x//i' | tr '[:upper:]' '[:lower:]')
                    
                    # Convert hex to decimal
                    # Format: 0xb01 = 2817 (decimal)
                    # If conversion fails, dec_value will be empty
                    dec_value=$(printf '%d' "0x$clean_hex" 2>/dev/null) || dec_value=""

                    if [ -n "$dec_value" ]; then
                        # Get length of hex string to handle different formats
                        hex_len=${#clean_hex}
                        
                        # Handle small hex values (≤ 2 digits)
                        if [ "$hex_len" -le 2 ]; then
                            major=0
                            minor=0
                            patch="$dec_value"
                        else
                            # Extract version components using bitwise operations:
                            # For hex b01 (2817 decimal):
                            # major: bits 15-12 (0 in this case)
                            # minor: bits 11-8  (11 in this case)
                            # patch: bits 7-0   (1 in this case)
                            major=$(( dec_value >> 12 & 15 ))  # Get highest 4 bits
                            minor=$(( dec_value >> 8 & 15 ))   # Get next 4 bits
                            patch=$(( dec_value & 255 ))       # Get lowest 8 bits
                        fi
                        
                        # Format version string (e.g., "0.11.1")
                        version_string="$major.$minor.$patch"
                        # Combine with binary version (e.g., "0.11.1 [11023]")
                        apatch_version="$version_string [$binary_version]"
                    else
                        apatch_version="Unknown"
                    fi
                fi
            else
                apatch_version="Unknown"
            fi
        else
            apatch_version="Unknown"
        fi
        # Final result (e.g., "APatch installed (0.11.1 [11023])")
        # I haven't tested it against older versions yet, but I'm sure it will works somehow and hopefully for the future versions as well
        echo "APatch installed ($apatch_version)"
    else
        echo 'Unknown root solution, possible candidates:'
        for candidate in /data/adb/*; do
            if [ -d "$candidate" ]; then
                dirname=$(basename "$candidate")
                case "$dirname" in
                    modules) ;; # not interested
                    post-fs-data.d) ;; # not interested
                    service.d) ;; # not interested
                    *) echo "$dirname" ;;
                esac
            fi
        done
        echo 'list end'
    fi
    if [ ! -e /data/adb ]; then
        echo 'Could not determine if Busybox for Android NDK Magisk module is installed'
    elif [ -e /data/adb/modules/busybox-ndk ]; then
        echo 'Busybox for Android NDK Magisk module installed'
    else
        echo 'Busybox for Android NDK Magisk module not installed'
    fi
    # don't want machine name, otherwise -a would be easiest
    if [ "unknown" != "$(uname -p)" ]; then
        uname -s -r -v -m -p -i -o
    else
        uname -s -r -v -m -o
    fi
    echo "PATH=$PATH"
    # check run successfully, bail out
    exit 0
fi

getopt --test > /dev/null && true
if [ $? -ne 4 ]; then
    # shellcheck disable=SC2016
    echo 'I'\''m sorry, `getopt --test` failed in this environment.'
    echo "Run '$script env' for extra information"
    exit 1
fi

if ! tar --help 2>&1 | grep -q -- "-J" ; then
    echo 'Your Busybox tar does not support xz compression. Update your busybox!'
    exit 1
fi

mkdir -p "$chroot_distro_path" "$chroot_distro_path/.rootfs" "$chroot_distro_path/.backup"

chroot_distro_warn_if_unsupported_busybox() {
    if [ "" != "$unsupported_busybox" ]; then
        echo "Warning: You are using Magisk/KernelSU/APatch without Busybox for Android NDK installed."
        echo "You may experience bugs as this is community supported environment."
    fi
}

chroot_distro_help() {
    echo "$script : install linux distributions

usage :

$script help - for more information
$script env - output debug information about environment
$script list - list of available linux distributions

$script download <distro> - download rootfs
$script redownload <distro> - redownload rootfs
$script delete <distro> - delete rootfs

$script install <distro> [-a|--android] - install distro
    '-a|--android'  Installs also /data and /system folders, by default not installed
$script reinstall <distro> [-a|--android] [-f|--force] - reinstall distro
    '-a|--android'  Installs also /data and /system folders, by default not installed
    '-f|--force'    Force closing open files (closes the process accessing them)
                    and/or unmounting active mounts. Use with care.
$script uninstall <distro> [-f|--force] - uninstall distro
    '-f|--force'    Force closing open files (closes the process accessing them)
                    and/or unmounting active mounts. Use with care.

$script unmount <distro> [-f|--force] [-a|--all] - unmount (system) mount points from distro
    '-f|--force'    Force closing open files (closes the process accessing them)
                    and/or unmounting active mounts which prevents (system) mount points
                    from unmounting. Use with care.
    '-a|--all'      Instead of unmounting only system mount points, will try to unmount
                    all found mount points, be it a normal mount point or a loopback mount point.

$script backup <distro> [<path>] - backup distro
    <path>          Custom path for backup location
$script restore <distro> [-d|--default] [--force] [<path>] - restore distro
    <path>          Custom path for backup location
    '-d|--default'  restore default settings (note: only those set during install)
    '--force'       Force restore even if may cause unintended side-effects
$script unbackup <distro> - delete backup from default location

$script command <distro> <command> - run command
$script login <distro> - login to distro
"

    chroot_distro_warn_if_unsupported_busybox
}

chroot_distro_list_item() {
    if [ -f "$chroot_distro_path/.rootfs/$1.tar.xz" ]; then
        echo "Downloaded : Yes"
    else
        echo "Downloaded : No"
    fi
    if [ -d "$chroot_distro_path/$1/" ]; then
        echo "Installed: Yes"
    else
        echo "Installed: No"
    fi
    if [ -f "$chroot_distro_path/.backup/$1.tar.xz" ]; then
        echo "Backup : Yes"
    else
        echo "Backup : No"
    fi
    echo
}

# Notice: if you change one of the base urls, remember to check that the full download link is still correct
# as some of the full urls may have the version information multiple times
proot_distro_rootfs_base_url=https://github.com/termux/proot-distro/releases/download 
anlinux_rootfs_base_url=https://github.com/EXALAB/Anlinux-Resources
# proot distro rootfs: 
debian_rootfs_base_url_prootdistro=$proot_distro_rootfs_base_url/v4.7.0/
manjaro_rootfs_base_url=$proot_distro_rootfs_base_url/v4.14.1/
openkylin_rootfs_base_url=$proot_distro_rootfs_base_url/v4.10.0/
pardus_rootfs_base_url=$proot_distro_rootfs_base_url/v4.6.0/
opensuse_rootfs_base_url=$proot_distro_rootfs_base_url/v4.6.0/
artix_rootfs_base_url=$proot_distro_rootfs_base_url/v4.6.0/
deepin_rootfs_base_url=$proot_distro_rootfs_base_url/v4.16.0/
rocky_rootfs_base_url=$proot_distro_rootfs_base_url/v4.20.0/
# Official rootfs: 
ubuntu_rootfs_base_url=https://cdimage.ubuntu.com/ubuntu-base/releases/
kali_rootfs_base_url=http://kali.download/nethunter-images/
alpine_rootfs_base_url=http://dl-cdn.alpinelinux.org/alpine/latest-stable/releases/
void_rootfs_base_url=https://repo-default.voidlinux.org/live/
archlinux_rootfs_base_url_arm=http://ca.us.mirror.archlinuxarm.org/os/
archlinux_rootfs_base_url=https://mirrors.ocf.berkeley.edu/archlinux/iso/latest/
adelie_rootfs_base_url=https://distfiles.adelielinux.org/adelie/1.0-beta6/iso/
gentoo_rootfs_base_url=https://distfiles.gentoo.org/releases/
chimera_rootfs_base_url=https://repo.chimera-linux.org/live/
# AnLinux rootfs: 
debian_rootfs_base_url_anlinux=$anlinux_rootfs_base_url/raw/master/Rootfs/Debian/
parrot_rootfs_base_url=$anlinux_rootfs_base_url/raw/master/Rootfs/Parrot/
backbox_rootfs_base_url=$anlinux_rootfs_base_url/raw/master/Rootfs/BackBox/
centos_rootfs_base_url=$anlinux_rootfs_base_url/raw/master/Rootfs/CentOS/
centos_stream_rootfs_base_url=$anlinux_rootfs_base_url/raw/master/Rootfs/CentOS_Stream/

chroot_distro_list() {
    echo "Ubuntu : ubuntu
Rootfs : $ubuntu_rootfs_base_url"
    chroot_distro_list_item ubuntu
    echo "Kali Linux : kali
Rootfs : $kali_rootfs_base_url"
    chroot_distro_list_item kali
    echo "Debian : debian
Rootfs : $debian_rootfs_base_url_anlinux
Rootfs : $debian_rootfs_base_url_prootdistro"
    chroot_distro_list_item debian
    echo "Parrot OS : parrot
Rootfs : $parrot_rootfs_base_url"
    chroot_distro_list_item parrot
    echo "Alpine : alpine
Rootfs : $alpine_rootfs_base_url"
    chroot_distro_list_item alpine
    echo "Void Linux : void
Rootfs : $void_rootfs_base_url"
    chroot_distro_list_item void
    if [ "$hardware_machine" != "i386" ]; then
        echo "Arch Linux : archlinux
Rootfs : $archlinux_rootfs_base_url_arm
Rootfs : $archlinux_rootfs_base_url"
        chroot_distro_list_item archlinux
    fi
    if [ "$hardware_machine" = "arm64" ]; then
        echo "Artix Linux : artix
Rootfs : $artix_rootfs_base_url"
        chroot_distro_list_item artix
    fi
    if [ "$hardware_machine" = "arm64" ] || [ "$hardware_machine" = "amd64" ]; then
        echo "Deepin : deepin
Rootfs : $deepin_rootfs_base_url"
        chroot_distro_list_item deepin
    fi
    if [ "$hardware_machine" = "arm64" ] || [ "$hardware_machine" = "amd64" ]; then
        echo "Fedora : fedora
Rootfs : $proot_distro_rootfs_base_url"
        chroot_distro_list_item fedora
    fi
    if [ "$hardware_machine" = "arm64" ]; then
        echo "Manjaro : manjaro
Rootfs : $manjaro_rootfs_base_url"
        chroot_distro_list_item manjaro
    fi
    if [ "$hardware_machine" = "arm64" ] || [ "$hardware_machine" = "amd64" ]; then
        echo "OpenKylin : openkylin
Rootfs : $openkylin_rootfs_base_url"
        chroot_distro_list_item openkylin
    fi
    if [ "$hardware_machine" != "armhf" ]; then
        echo "Pardus : pardus
Rootfs : $pardus_rootfs_base_url"
        chroot_distro_list_item pardus
    fi
    echo "OpenSuse : opensuse
Rootfs : $opensuse_rootfs_base_url"
    chroot_distro_list_item opensuse
    echo "BackBox : backbox
Rootfs : $backbox_rootfs_base_url"
    chroot_distro_list_item backbox
    if [ "$hardware_machine" = "arm64" ] || [ "$hardware_machine" = "amd64" ]; then
        echo "CentOS : centos
Rootfs : $centos_rootfs_base_url"
        chroot_distro_list_item centos
    fi
    if [ "$hardware_machine" = "arm64" ] || [ "$hardware_machine" = "amd64" ]; then
        echo "CentOS Stream : centos_stream
Rootfs : $centos_stream_rootfs_base_url"
        chroot_distro_list_item centos_stream
    fi
if [ "$hardware_machine" = "arm64" ] || [ "$hardware_machine" = "amd64" ]; then
        echo "Rocky : rocky
Rootfs : $rocky_rootfs_base_url"
        chroot_distro_list_item rocky 
    fi
if [ "$hardware_machine" = "arm64" ] || [ "$hardware_machine" = "amd64" ] || [ "$hardware_machine" = "armhf" ]; then
        echo "Adelie : adelie
Rootfs : $adelie_rootfs_base_url"
        chroot_distro_list_item adelie
    fi
if [ "$hardware_machine" = "arm64" ] || [ "$hardware_machine" = "amd64" ]; then
        echo "Chimera : chimera
Rootfs : $chimera_rootfs_base_url"
        chroot_distro_list_item chimera
    fi
echo "Gentoo : gentoo
Rootfs : $Gentoo_rootfs_base_url"
    chroot_distro_list_item gentoo
}

chroot_distro_download() {
    distro="$1"
    if [ "$distro" = "ubuntu" ]; then
        distro_name='Ubuntu'

        if [ "$hardware_machine" = "i386" ] || [ "$hardware_machine" = "arm64" ] || [ "$hardware_machine" = "armhf" ] || [ "$hardware_machine" = "amd64" ]; then
            echo "[1] ubuntu trusty 14.04"
            echo "[2] ubuntu xenial 16.04"
            echo "[3] ubuntu bionic 18.04"
        fi
        if [ "$hardware_machine" != "i386" ]; then
            echo "[4] ubuntu focal 20.04"
            echo "[5] ubuntu jammy 22.04"
            echo "[6] ubuntu noble 24.04"
            echo "[7] ubuntu oracular 24.10"
            echo "[8] ubuntu plucky 25.04"
        fi
        while true; do
            printf "Enter a number (1-8, or 'q' to quit): " 
            read -r number
            case "$number" in
                1) release="trusty"; break;;
                2) release="xenial"; break;;
                3) release="bionic"; break;;
                4) release="focal"; break;;
                5) release="jammy"; break;;
                6) release="noble"; break;;
                7) release="oracular"; break;; 
                8) release="plucky"; break;; 
                q) echo "Operation cancelled"; exit 1;;
                *) echo "Invalid option: $number. Please try again.";;
            esac
        done

        version=$(curl -s ${ubuntu_rootfs_base_url}${release}/release/ | grep -oE "ubuntu-base-[0-9]+\.[0-9]+-base-${hardware_machine}\.tar\.gz" | head -n 1 | sed -E 's/ubuntu-base-([0-9]+\.[0-9]+)-.*/\1/')
        download_url="${ubuntu_rootfs_base_url}${release}/release/ubuntu-base-${version}-base-${hardware_machine}.tar.gz"

    elif [ "$distro" = "alpine" ]; then
        distro_name='Alpine'
        echo "[1] alpine minirootfs latest"
        echo "[2] alpine netboot latest"
        echo "[3] alpine rpi latest"
        echo "[4] alpine uboot latest"
        while true; do
            printf "Enter a number (1-4, or 'q' to quit): "
            read -r number
            case "$number" in
                1) rootfs="minirootfs";break;;
                2) rootfs="netboot"; break;;
                3) rootfs="rpi"; break;;
                4) rootfs="uboot";break;;
                q) echo "Operation cancelled"; exit 1;;
                *) echo "Invalid option: $number. Please try again.";;
            esac
        done

        hwm_alpine=$(echo $hardware_machine | sed s/arm64/aarch64/g | sed s/amd64/x86_64/g | sed s/i386/x86/g)
        download_url="$alpine_rootfs_base_url$hwm_alpine/alpine-$rootfs-$(curl -s $alpine_rootfs_base_url$hwm_alpine/ | grep -oE 'alpine-.*[0-9]+\.[0-9]+\.[0-9]+[^"]*(.tar.gz|.tar|.img)' | sed -E 's/.*([0-9]+\.[0-9]+\.[0-9]+).*/\1/' | sort -V | tail -n 1)-$hwm_alpine.tar.gz"

    elif [ "$distro" = "kali" ]; then
        distro_name='Kali Linux'
        echo "[1] kali linux full"
        echo "[2] kali linux minimal"
        echo "[3] kali linux nano"
        while true; do
            printf "Enter a number (1-3, or 'q' to quit): "
            read -r number
            case "$number" in
                1) rootfs="full"; break;;
                2) rootfs="minimal"; break;;
                3) rootfs="nano"; break;;
                q) echo "Operation cancelled"; exit 1;;
                *) echo "Invalid option: $number. Please try again.";;
            esac
        done

        version="$(curl -s $kali_rootfs_base_url | grep -oE "kali-nethunter-[0-9]+\.[0-9]+-generic-${hardware_machine}-${rootfs_version}\.zip" | head -n 1 | sed -E 's/kali-nethunter-([0-9]+\.[0-9]+)-.*/\1/')"
        download_url="${kali_rootfs_base_url}current/kali-nethunter-${version}-generic-${hardware_machine}-${rootfs_version}\.zip"

    elif [ "$distro" = "debian" ]; then
        distro_name='Debian'
        echo "[1] Debian (AnLinux)"
        echo "[2] Debian bullseye (proot-distro)"
        echo "[3] Debian bookworm (proot-distro)"
        while true; do
            printf "Enter a number (1-3, or 'q' to quit): "
            read -r number
            case "$number" in
                1) rootfs="debian"; break;;
                2) rootfs="debian_bullseye"; break;;
                3) rootfs="debian_bookworm";break;;
                q) echo "Operation cancelled"; exit 1;;
                *) echo "Invalid option: $number. Please try again.";;
            esac
        done

        if [ "$rootfs" = "debian" ]; then
            download_url="$debian_rootfs_base_url_anlinux$hardware_machine/debian-rootfs-$hardware_machine.tar.xz"
        elif [ "$rootfs" = "debian_bullseye" ]; then
            download_url="${debian_rootfs_base_url_prootdistro}debian-bullseye-$(echo $hardware_machine | sed s/arm64/aarch64/g | sed s/amd64/x86_64/g | sed s/i386/i686/g | sed s/armhf/arm/g)-pd-v4.7.0.tar.xz"
        elif [ "$rootfs" = "debian_bookworm" ]; then
            download_url="${debian_rootfs_base_url_prootdistro}debian-bookworm-$(echo $hardware_machine | sed s/arm64/aarch64/g | sed s/amd64/x86_64/g | sed s/i386/i686/g | sed s/armhf/arm/g)-pd-v4.7.0.tar.xz"
        fi

    elif [ "$distro" = "parrot" ]; then
        distro_name='Parrot OS'

        download_url="$parrot_rootfs_base_url$hardware_machine/parrot-rootfs-$hardware_machine.tar.xz"

    elif [ "$distro" = "archlinux" ]; then
        distro_name='Arch Linux'

        if [ "$hardware_machine" = "armhf" ]; then
            download_url="${archlinux_rootfs_base_url_arm}ArchLinuxARM-armv7-latest.tar.gz"
        elif [ "$hardware_machine" = "arm64" ]; then
            download_url="${archlinux_rootfs_base_url_arm}ArchLinuxARM-aarch64-latest.tar.gz"
        elif [ "$hardware_machine" = "amd64" ]; then
            download_url="${archlinux_rootfs_base_url}archlinux-bootstrap-x86_64.tar.gz"
        fi

    elif [ "$distro" = "artix" ]; then
        distro_name='Artix Linux'

        if [ "$hardware_machine" = "arm64" ]; then
            download_url="${artix_rootfs_base_url}artix-aarch64-pd-v4.6.0.tar.xz"
        fi

    elif [ "$distro" = "deepin" ]; then
        distro_name='Deepin'

        if [ "$hardware_machine" = "arm64" ]; then
            download_url="${deepin_rootfs_base_url}deepin-aarch64-pd-v4.16.0.tar.xz"
        elif [ "$hardware_machine" = "amd64" ]; then
            download_url="${deepin_rootfs_base_url}deepin-x86_64-pd-v4.16.0.tar.xz"
        fi

    elif [ "$distro" = "fedora" ]; then
        distro_name='Fedora'
        echo "[1] fedora 4.24.0"
        echo "[2] fedora 4.23.0"
        echo "[3] fedora 4.17.3"
        echo "[4] fedora 4.15.0"
        while true; do
            printf "Enter a number (1-4, or 'q' to quit): " 
            read -r number
            case "$number" in
                1) release_version="4.24.0"; break;;
                2) release_version="4.23.0"; break;;
                3) release_version="4.17.3"; break;;
                4) release_version="4.15.0"; break;;
                q) echo "Operation cancelled"; exit 1;;
                *) echo "Invalid option: $number. Please try again.";;
            esac
        done
        if [ "$hardware_machine" = "arm64" ]; then
            download_url="${proot_distro_rootfs_base_url}/${release_version}/fedora-aarch64-pd-${release_version}.tar.xz"
        elif [ "$hardware_machine" = "amd64" ]; then
            download_url="${proot_distro_rootfs_base_url}/${release_version}/fedora-x86_64-pd-${release_version}.tar.xz"
        fi

    elif [ "$distro" = "openkylin" ]; then
        distro_name='OpenKylin'

        if [ "$hardware_machine" = "arm64" ]; then
            download_url="${openkylin_rootfs_base_url}openkylin-aarch64-pd-v4.10.0.tar.xz"
        elif [ "$hardware_machine" = "amd64" ]; then
            download_url="${openkylin_rootfs_base_url}openkylin-x86_64-pd-v4.10.0.tar.xz"
        fi
        elif [ "$distro" = "rocky" ]; then
        distro_name='Rocky'

        if [ "$hardware_machine" = "arm64" ]; then
            download_url="${rocky_rootfs_base_url}rocky-aarch64-pd-v4.20.0.tar.xz"
        elif [ "$hardware_machine" = "amd64" ]; then
            download_url="${rocky_rootfs_base_url}rocky-x86_64-pd-v4.20.0.tar.xz"
        fi
        elif [ "$distro" = "chimera" ]; then
        distro_name='Chimera'
        echo "[1] chimera full"
        echo "[2] chimera minimal"
        while true; do
            printf "Enter a number (1-2, or 'q' to quit): "
            read -r number
            case "$number" in
                1) rootfs="full"; break;;
                2) rootfs="bootstrap"; break;;
                q) echo "Operation cancelled"; exit 1;;
                *) echo "Invalid option: $number. Please try again.";;
            esac
        done
        if [ "$hardware_machine" = "arm64" ]; then
            version="$(curl -s ${chimera_rootfs_base_url}latest | grep -oE "chimera-linux-aarch64-ROOTFS-[0-9]{8}-${rootfs}\.tar.gz" | sed -E 's/.*chimera-linux-aarch64-ROOTFS-([0-9]{8})-${rootfs}\.tar\.gz/\1/' | head -n 1)"
            download_url="${chimera_rootfs_base_url}latest/chimera-linux-aarch64-ROOTFS-${version}-${rootfs}\.tar.gz"
        elif [ "$hardware_machine" = "amd64" ]; then
            version="$(curl -s ${chimera_rootfs_base_url}latest | grep -oE "chimera-linux-aarch64-ROOTFS-[0-9]{8}-${rootfs}\.tar.gz" | sed -E 's/.*chimera-linux-x86_64-ROOTFS-([0-9]{8})-${rootfs}\.tar\.gz/\1/' | head -n 1)"
            download_url="${chimera_rootfs_base_url}latest/chimera-linux-x86_64-ROOTFS-${version}-${rootfs}\.tar.gz"
        fi
       elif [ "$distro" = "adelie" ]; then
        distro_name='Adelie'
        echo "[1] adelie linux full"
        echo "[2] adelie linux minimal"

        while true; do
            printf "Enter a number (1-2, or 'q' to quit): "
            read -r number
            case "$number" in
                1) rootfs="full"; break;;
                2) rootfs="minimal"; break;;
                q) echo "Operation cancelled"; exit 1;;
                *) echo "Invalid option: $number. Please try again.";;
            esac
        done

        case "$hardware_machine" in
           arm64) version=$(curl -s "$adelie_rootfs_base_url" | grep -oE "adelie-rootfs-${rootfs}-aarch64-[^\" ]+-[0-9]{8}\.txz" | sed -E 's/.*-([0-9]{8})\.txz/\1/' | head -n 1); download_url="${adelie_rootfs_base_url}adelie-rootfs-${rootfs}-aarch64-1.0-beta6-${version}.txz";;
           armhf) version=$(curl -s "$adelie_rootfs_base_url" | grep -oE "adelie-rootfs-${rootfs}-armv7-[^\" ]+-[0-9]{8}\.txz" | sed -E 's/.*-([0-9]{8})\.txz/\1/' | head -n 1); download_url="${adelie_rootfs_base_url}adelie-rootfs-${rootfs}-armv7-1.0-beta6-${version}.txz";;
           amd64) version=$(curl -s "$adelie_rootfs_base_url" | grep -oE "adelie-rootfs-${rootfs}-x86_64-[^\" ]+-[0-9]{8}\.txz" | sed -E 's/.*-([0-9]{8})\.txz/\1/' | head -n 1); download_url="${adelie_rootfs_base_url}adelie-rootfs-${rootfs}-x86_64-1.0-beta6-${version}.txz";;
        esac
    elif [ "$distro" = "manjaro" ]; then
        distro_name='Manjaro'

        if [ "$hardware_machine" = "arm64" ]; then
            download_url="${manjaro_rootfs_base_url}manjaro-aarch64-pd-v4.14.1.tar.xz"
        fi

    elif [ "$distro" = "opensuse" ]; then
        distro_name='OpenSuse'

        download_url="${opensuse_rootfs_base_url}opensuse-$(echo $hardware_machine | sed s/arm64/aarch64/g | sed s/amd64/x86_64/g | sed s/i386/i686/g | sed s/armhf/arm/g)-pd-v4.6.0.tar.xz"

    elif [ "$distro" = "pardus" ]; then
        distro_name='Pardus'

        if [ "$hardware_machine" != "armhf" ]; then
            download_url="${pardus_rootfs_base_url}pardus-$(echo $hardware_machine | sed s/arm64/aarch64/g | sed s/amd64/x86_64/g | sed s/i386/i686/g | sed s/armhf/arm/g)-pd-v4.6.0.tar.xz"
        fi

    elif [ "$distro" = "backbox" ]; then
        distro_name='BackBox'

        download_url="$backbox_rootfs_base_url$hardware_machine/backbox-rootfs-$hardware_machine.tar.xz"

    elif [ "$distro" = "centos" ]; then
        distro_name='CentOS'

        if [ "$hardware_machine" = "arm64" ]; then
            download_url="${centos_rootfs_base_url}arm64/centos-rootfs-arm64.tar.xz"
        elif [ "$hardware_machine" = "amd64" ]; then
            download_url="${centos_rootfs_base_url}amd64/centos-rootfs-amd64.tar.xz"
        fi

    elif [ "$distro" = "centos_stream" ]; then
        distro_name='CentOS Stream'

        if [ "$hardware_machine" = "arm64" ]; then
            download_url="${centos_stream_rootfs_base_url}arm64/centos_stream-rootfs-arm64.tar.xz"
        elif [ "$hardware_machine" = "amd64" ]; then
            download_url="${centos_stream_rootfs_base_url}amd64/centos_stream-rootfs-amd64.tar.xz"
        fi
        elif [ "$distro" = "gentoo" ]; then
        distro_name='gentoo'
        case "$hardware_machine" in
            arm64|amd64|i386) arch="$hardware_machine" ;;
            armhf) arch="armv7a" ;;
           *) exit 1 ;;
        esac
       version=$(curl -s "https://distfiles.gentoo.org/releases/${arch}/autobuilds/current-stage3-${arch}-openrc/" | grep -oE "stage3-${arch}-openrc-[0-9]{8}T[0-9]{6}Z\.tar\.xz" | sed -E "s/.*stage3-${arch}-openrc-([0-9]{8}T[0-9]{6}Z)\.tar\.xz/\1/" | head -n 1)
       download_url="${gentoo_rootfs_base_url}${arch}/autobuilds/current-stage3-${arch}-openrc/stage3-${arch}-openrc-${version}.tar.xz"
    elif [ "$distro" = "void" ]; then
        distro_name='Void Linux'
        download_url="${void_rootfs_base_url}current/void-$(echo $hardware_machine | sed s/arm64/aarch64/g | sed s/amd64/x86_64/g | sed s/i386/i686/g | sed s/armhf/armv7l/g)-ROOTFS-$(curl -s ${void_rootfs_base_url}current/ | grep -oE 'void-.*-ROOTFS-[0-9]+\.tar\.xz' | head -n 1 | sed -E 's/.*-ROOTFS-([0-9]+)\.tar\.xz/\1/').tar.xz"
    else
        echo "Unavailable distro: $distro"
        exit 90
    fi

    if [ "" = "$download_url" ]; then
        echo "Unsupported machine hardware: $(uname -m)"
        exit 87
    fi

    if [ -f "$chroot_distro_path/.rootfs/$distro.tar.xz" ]; then
        echo "Already downloaded."
        exit 89
    fi

    if ! wget -O "$chroot_distro_path/.rootfs/$distro.tar.xz" "$download_url"; then
        echo "Failed to download the $distro_name Rootfs."
        if [ -e "$chroot_distro_path/.rootfs/$distro.tar.xz" ]; then
            rm "$chroot_distro_path/.rootfs/$distro.tar.xz"
        fi
        exit 88
    fi
}

chroot_distro_check_if_supported() {
    for distro in $supported_distros; do
        if [ "$distro" = "$1" ]; then
            return 0
        fi
    done
    echo "unavailable distro $1"
    exit 1
}

chroot_distro_find_processes_with_open_files() {
    path="$1"
    if [ "" != "$busyboxlsof" ]; then
        # busybox has own format for lsof output
        lsof | grep -F "$path" | grep -Eo '^[[:digit:]]+' | sort -n | uniq
    else
        lsof | grep -F "$path" | cut -c10- | grep -Eo '^ *[[:digit:]]+' | grep -Eo '[[:digit:]]+' | sort -n | uniq
    fi
}

chroot_distro_find_all_mount_points() {
    path="$1"
    mount | grep -F "$path" | grep -Eo '^[[:alnum:][:punct:]\/]+ on [[:alnum:][:punct:]\/]+' | grep -Eo '[[:alnum:][:punct:]\/]+$'
}

chroot_distro_find_all_loopback_mount_points() {
    path="$1"
    losetup -a | grep -F "$path" | grep -Eo '^[^:]+'
}

chroot_distro_delete() {
    chroot_distro_check_if_supported "$1"

    archive_path="$chroot_distro_path/.rootfs/$1.tar.xz"
    if [ -f "$archive_path" ]; then
        rm "$archive_path"
    else
        echo "$1 not downloaded"
        exit 1
    fi
}

chroot_distro_output_system_mount_point_paths() {
    distro_path="$1"
    storage_paths=$(
        for file in "/storage"/*; do
            echo "$distro_path$file"
        done)
    while read -r path_to_test; do
        case "$path_to_test" in
            *"$distro_path/data/"*) echo "$path_to_test" ;;
            *"$distro_path/system/"*) echo "$path_to_test" ;;
            *"$distro_path/sdcard/"*) echo "$path_to_test" ;;
            *"$distro_path/dev/pts/"*) echo "$path_to_test" ;;
            *"$distro_path/proc/"*) echo "$path_to_test" ;;
            *"$distro_path/sys/"*) echo "$path_to_test" ;;
            *"$distro_path/dev/"*) echo "$path_to_test" ;;
            *"$distro_path/storage/"*)
                # storage check could have been just one line like the above ones but wanted to have only
                # the cases which prevents the unmount visible (ie. storage or storage/emulated are not visible)
                echo "$storage_paths" | while read -r storage_path; do
                    case "$path_to_test" in
                        *"$storage_path/"*) echo "$path_to_test" ;;
                        *) ;;
                    esac
                done
            ;;
            *) ;; # everything else, ignore
        esac
    done
}

chroot_distro_mount_system_point() {
    path_to_mount="$1"
    mount_point="$2"
    if [ ! -e "$path_to_mount" ]; then
        echo "Warning: Missing system path $path_to_mount, skipping"
        return
    fi
    if [ ! -d "$mount_point" ]; then
        if ! mkdir -p "$mount_point"; then
            echo "creating mount point $mount_point failed"
            exit 1
        fi
    fi
    if mountpoint -q "$mount_point"; then
        # nothing to do, already mounted
        return
    fi
    if ! mount --bind "$path_to_mount" "$mount_point"; then
        echo "could not mount $path_to_mount to $mount_point"
        exit 1
    fi
}

chroot_distro_mount_system_points() {
    distro_path="$1"
    use_android="$2"
    chroot_distro_mount_system_point /dev "$distro_path/dev"
    chroot_distro_mount_system_point /sys "$distro_path/sys"
    chroot_distro_mount_system_point /proc "$distro_path/proc"
    chroot_distro_mount_system_point /dev/pts "$distro_path/dev/pts"
    chroot_distro_mount_system_point /sdcard "$distro_path/sdcard"
    if [ "yes" = "$use_android" ] || [ -d "$distro_path/system" ]; then
        chroot_distro_mount_system_point /system "$distro_path/system"
    fi
    if [ "yes" = "$use_android" ] || [ -d "$distro_path/data" ]; then
        chroot_distro_mount_system_point /data "$distro_path/data"
    fi
    for file in "/storage"/*; do
        # no need for separator as separator already comes from file variable itself
        chroot_distro_mount_system_point "$file" "$distro_path$file"
    done
}

chroot_distro_unmount_system_point() {
    mount_point="$1"
    force="$2"
    if [ ! -e "$mount_point" ]; then
        # nothing to do, mount point missing
        return
    fi
    if ! mountpoint -q "$mount_point"; then
        # nothing to do, already unmounted
        return
    fi
    if [ "yes" = "$force" ]; then
        # first try to kill all processes before trying to unmount anything
        # note: close from earlier to later processes to ensure that no new worker processes are created during killing
        chroot_distro_find_processes_with_open_files "$mount_point/" | xargs -I {} kill {} > /dev/null 2>&1
        # before normal unmounts, go through all loopback devices
        # note: in reverse order in case there is loopback mount from inside the loopback mount (quite contrived case but just in case...)
        chroot_distro_find_all_loopback_mount_points "$mount_point/" | sort -r | xargs -I {} umount {} > /dev/null 2>&1
        # try to unmount everything found
        # note: using reverse sort to ensure that mounts residing deeper in the file system will be unmmounted first
        chroot_distro_find_all_mount_points "$mount_point/" | sort -r | xargs -I {} umount {} > /dev/null 2>&1
        # then hope for the best...
    fi
    # no need to check for the success as the caller will take care of that
    if ! umount "$mount_point" || true; then
    echo "Warning: Failed to unmount $mount_point"
    fi
}

chroot_distro_unmount_system_points() {
    distro_path="$1"
    force="$2"
    for file in "/storage"/*; do
        # no need for separator as separator already comes from file variable itself
        chroot_distro_unmount_system_point "$distro_path$file" "$force"
    done
    chroot_distro_unmount_system_point "$distro_path/data" "$force"
    chroot_distro_unmount_system_point "$distro_path/system" "$force"
    chroot_distro_unmount_system_point "$distro_path/sdcard" "$force"
    chroot_distro_unmount_system_point "$distro_path/dev/pts" "$force"
    chroot_distro_unmount_system_point "$distro_path/proc" "$force"
    chroot_distro_unmount_system_point "$distro_path/sys" "$force"
    chroot_distro_unmount_system_point "$distro_path/dev" "$force"
}

chroot_distro_check_if_system_point_mounted() {
    mount_point="$1"
    if [ ! -e "$mount_point" ]; then
        # nothing to do, mount point missing
        return 1
    fi
    if mountpoint -q "$mount_point" 2>/dev/null || true; then
       return 0
    else
       return 1
    fi
}

chroot_distro_check_if_system_points_mounted() {
    distro_path="$1"
    # shellcheck disable=SC2089
    # quotes are intentionally added
    # dev/pts is not checked as it is assumed that if dev is mounted then also pts is mounted and if dev is not mounted then pts is not mounted
    system_paths="'$distro_path/dev' '$distro_path/sys' '$distro_path/proc' '$distro_path/sdcard' '$distro_path/system' '$distro_path/data'"
    for file in "/storage"/*; do
        # no need for separator as separator already comes from file variable itself
        system_paths="$system_paths '$distro_path$file'"
    done

    # shellcheck disable=SC2090
    # shellcheck disable=SC2086
    # double quotes are intentionally omitted
    set -- $system_paths
    partial=
    quote="'"
    while [ $# -gt 0 ]
    do
        # This case shenanigan is required to ensure that if there is space in the path that the path is constructed properly
        # as we don't use quotes for set parameters. There is still possibility of somebody intentionally using path "/some' /path".
        # In this case the path will be split wrongly but then again there is likely more pressing issues if somebody gets to do that.
        case "$1" in
            *$quote)
                if [ "" = "$partial" ]; then
                    full="$1"
                else
                    full="$partial $1"
                fi
                partial=
                # strip quotes, assumes that path is 'some/path', ie. both start and end has quotes
                full="${full:1:${#full}-2}"

                if chroot_distro_check_if_system_point_mounted "$full"; then
                    return 0
                fi
                ;;
            *)
                if [ "" = "$partial" ]; then
                    partial="$1"
                else
                    partial="$partial $1"
                fi
                ;;
        esac
        shift
    done
    return 1
}

chroot_distro_check_archive_file_type() {
    archive_path="$1"

    # -l option would be more efficient but unfortunately busybox implementation may not support it
    if gunzip -t "$archive_path" 1>/dev/null 2>&1 ; then
        echo "gzip"
        return
    fi
    # -l option would be more efficient but unfortunately busybox implementation may not support it
    if xz -t "$archive_path" 1>/dev/null 2>&1 ; then
        echo "xz"
        return
    fi
    if tar -tf "$archive_path" 1>/dev/null 2>&1 ; then
        # either it is real tar file, or something else which isn't gunzip or xz
        echo "tar"
        return
    fi
}

chroot_distro_find_su() {
    root=$1
    su_command=""
    if [ -f "$root/bin/su" ] || [ -L "$root/bin/su" ]; then
        su_command=/bin/su
    elif [ -f "$root/usr/bin/su" ] || [ -L "$root/usr/bin/su" ]; then
        su_command=/usr/bin/su
    elif [ -f "$root/usr/local/bin/su" ] || [ -L "$root/usr/local/bin/su" ]; then
        su_command=/usr/local/bin/su
    fi
    echo "$su_command"
}

chroot_distro_jail() {
    distro_path=$1
    command=$2
    su_command=$(chroot_distro_find_su "$distro_path")

    if [ "" != "$su_command" ]; then
        (
            # try to ensure that su will do as proper login as possible to ensure consistent environment
            unset PREFIX;
            if [ "" != "$command" ]; then
                # shellcheck disable=SC1007
                PATH= chroot "$distro_path/" "$su_command" - root -c "$command"
            else
                # shellcheck disable=SC1007
                PATH= chroot "$distro_path/" "$su_command" - root
            fi
        )
        return
    fi

    echo "Warning: Missing 'su' command, can't do a proper login. Please, install 'su'"
    echo "as soon as possible to ensure consistent login environment."

    # ensure a sane PATH contents for the shell
    JAIL_PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

    JAIL_HOME=/
    if [ -d "$distro_path/root" ]; then
        JAIL_HOME=/root
    fi

    (
        # try to ensure consistent environment
        unset HISTFILE;
        unset TMPDIR;
        unset PREFIX;
        unset BOOTCLASSPATH;
        unset SYSTEMSERVERCLASSPATH;
        unset LD_LIBRARY_PATH;
        if [ "" != "$command" ]; then
            SHELL=/bin/sh HOME="$JAIL_HOME" PATH="$JAIL_PATH" chroot "$distro_path/" /bin/sh -lc "$command"
        else
            SHELL=/bin/sh HOME="$JAIL_HOME" PATH="$JAIL_PATH" chroot "$distro_path/" /bin/sh -l
        fi
    )
}

chroot_distro_install() {
    distro=$1
    use_android=$2
    chroot_distro_check_if_supported "$distro"

    archive_path="$chroot_distro_path/.rootfs/$distro.tar.xz"
    if [ ! -f "$archive_path" ]; then
        echo "$distro not downloaded"
        exit 1
    fi

    distro_path="$chroot_distro_path/$distro"
    if [ -d "$distro_path" ]; then
        echo "$distro already installed"
        exit 1
    fi

    common_path="$( chroot_distro_find_archive_common_path "$archive_path" )"
    # shellcheck disable=SC2181
    # we want both the output and error code, so need indirection
    if [ $? -ne 0 ]; then
        # Something went wrong with finding the archive common path
        return $?
    fi
    if [ "" = "$common_path" ]; then
        common_path="."
    fi
    rootdir="$( echo "$common_path" | cut -f1 -d/ )"
    if [ "$rootdir" != "$common_path" ]; then
        echo "Unsupported archive. rootfs archive is expected to have only at most one subdirectory before the actual content."
        exit 1
    fi
    archive_type=${archive_type-$(chroot_distro_check_archive_file_type "$archive_path")}
    if [ "" = "$archive_type" ]; then
        echo "Error: unsupported or corrupt archive"
        exit 5
    fi
    if [ "." = "$rootdir" ]; then
        mkdir -p "$distro_path"
        if ! tar -xf "$archive_path" -C "$distro_path/"; then
            echo "Error: Unpacking the archive failed"
            exit 5
        fi
    else
        tar -xf "$archive_path" -C "$chroot_distro_path/"
        tar_status=$?
        if [ $tar_status -ne 0 ] && [ ! -e "$chroot_distro_path/$rootdir" ]; then
            # can bail out early as no files were unpacked
            echo "Error: Unpacking the archive failed"
            exit 5
        fi
        mv "$chroot_distro_path/$rootdir" "$distro_path"
        if [ $tar_status -ne 0 ]; then
            # can bail out only when the environment is in semi consistent state
            echo "Error: Unpacking the archive failed"
            exit 5
        fi
    fi

    chroot_distro_mount_system_points "$distro_path" "$use_android"

    resolvconf="$distro_path"/etc/resolv.conf
    if [ -L "$resolvconf" ] && [ ! -f "$resolvconf" ]; then
        # broken link
        rm "$resolvconf"
    fi
    echo "nameserver 8.8.8.8" > "$resolvconf"
    echo "nameserver 8.8.4.4" >> "$resolvconf"
    cp /etc/hosts "$distro_path"/etc/hosts
    chroot "$distro_path" /sbin/groupadd -g 3003 aid_inet 2>/dev/null || true
    chroot "$distro_path" /sbin/groupadd -g 3004 aid_net_raw 2>/dev/null || true
    chroot "$distro_path" /sbin/groupadd -g 1003 aid_graphics 2>/dev/null || true
    chroot "$distro_path" /sbin/usermod -g 3003 -G 3003,3004 -a _apt 2>/dev/null || true
    chroot "$distro_path" /sbin/usermod -G 3003 -a root 2>/dev/null || true
    timezone="$(getprop persist.sys.timezone)"
    chroot "$distro_path" /bin/ln -sf /usr/share/zoneinfo/$timezone /etc/localtime 2>/dev/null || true
    unset timezone
    chroot "$distro_path" /sbin/locale-gen en_US.UTF-8 2>/dev/null || true
    chroot_distro_jail "$distro_path"
}

chroot_distro_list_unmount_issues() {
    distro_path=$1
    command=$2
    mode=$3
    force=$4
    mounts=$5
    loopbacks=$6
    open_files=$7

    unset maybe_more
    if [ "all" != "$mode" ]; then
        maybe_more=true
    fi
    # note: if there is still system mount points mounted without a valid reason, please create a bug report so that it can be investigated
    echo 'distro is potentially running - if needed shutdown the distro, and unmount mounted folders'
    echo
    if [ "yes" != "$force" ]; then
        echo "You can try running $command again with -f(--force) option to automatically close/unmount files/folders mentioned below."
        echo 'Please note, that using --force option may close more programs than intended, so use it with care.'
    fi
    echo
    echo "open files under $distro_path${maybe_more+ (which affects unmounting, there may be more)}:"
    if [ "" = "$lsofpath" ]; then
        echo "Warning: supported lsof not found, run \`lsof | grep -F '$distro_path/'\` manually"
    fi
    echo "${open_files:-Not found}"
    echo "end of open files"
    echo
    echo "mount points under $distro_path${maybe_more+ (which affects unmounting, there may be more)}:"
    echo "${mounts:-Not found}"
    echo "end of mount points"
    echo
    echo "loopback devices under $distro_path${maybe_more+ (which affects unmounting, there may be more)}:"
    echo "${loopbacks:-Not found}"
    echo "end of loopback devices"
    echo
    echo "If there is no open files, mount points ${maybe_more-(outside of system mount points) }or loopback devices,"
    echo "then check for anonymous inodes and inotify watches"
}

chroot_distro_uninstall() {
    chroot_distro_check_if_supported "$1" 

    distro_path="$chroot_distro_path/$1"
    force=$2
    command=$3

    if [ -d "$distro_path" ]; then
        if [ "yes" = "$force" ]; then
            # first try to kill all processes before trying to unmount anything
            # note: close from earlier to later processes to ensure that no new worker processes are created during killing
            chroot_distro_find_processes_with_open_files "$distro_path/" | xargs -I {} kill {} > /dev/null 2>&1
            # before normal unmounts, go through all loopback devices
            # note: in reverse order in case there is loopback mount from inside the loopback mount (quite contrived case but just in case...)
            chroot_distro_find_all_loopback_mount_points "$distro_path/" | sort -r | xargs -I {} umount {} > /dev/null 2>&1
            # try to unmount everything found
            # note: using reverse sort to ensure that mounts residing deeper in the file system will be unmmounted first
            chroot_distro_find_all_mount_points "$distro_path/" | sort -r | xargs -I {} umount {} > /dev/null 2>&1
            # then hope for the best...
        fi
        chroot_distro_unmount_system_points "$distro_path" no
        mounts=$(mount | grep -F "$distro_path")
        loopbacks=$(losetup -a | grep -F "$distro_path")
        open_files=$(lsof | grep -F "$distro_path")
        if [ "" != "$mounts" ] || [ "" != "$loopbacks" ] || [ "" != "$open_files" ]; then
            chroot_distro_list_unmount_issues "$distro_path" "$command" 'all' "$force" "$mounts" "$loopbacks" "$open_files"
            exit 1
        fi

        # when reaching this point it is assumed that uninstalling the distro is ok, no irreversible changes to distro before this line

        # ensure that there is no symbolic links before nuking the rootfs, symbolic links may point outside of rootfs when outside of the chroot
        find "$distro_path" -type l -exec unlink {} \;
        rm -rf "$distro_path"
    else
        echo "$1 not installed"
        exit 1
    fi
}

chroot_distro_backup() {
    distro=$1
    custom_path=$2
    chroot_distro_check_if_supported "$distro" 

    distro_path="$chroot_distro_path/$1"
    if [ ! -d "$distro_path" ]; then
        echo "distro not installed, no need to backup"
        exit
    fi

    # Check system mount points, to ensure that we are not backing up a running system.
    # If system mount points are mounted then those will be backed up as well but in most
    # cases those are not wanted, as the restore will not work properly (mounts will shadow
    # the content). If data/sdcard etc. are needed to backup then it is better to do it
    # with different tool (for example twrp) and/or from inside the chroot
    if chroot_distro_check_if_system_points_mounted "$distro_path"; then
        echo "distro is potentially running - if needed shutdown the distro, and unmount system mount points ($script unmount $1) before proceeding"
        exit
    fi

    open_file_count=$(lsof | grep -Fc "$distro_path")
    if [ "" = "$lsofpath" ]; then
        echo "Warning: supported lsof not found, open files and/or programs currently running in jail will not be found."
        echo "In the case of errors run \`lsof | grep -F '$distro_path/'\` manually"
    elif [ "$open_file_count" -ne 0 ]; then
        echo "Warning: Open files detected, backup may fail (at least partially)"
    fi

    # mounted volumes should be backed up outside of this script as it may not work as intended
    # (same reasons as system mount points)
    mounts=$(mount | grep -F "$distro_path")
    loopbacks=$(losetup -a | grep -F "$distro_path")
    if [ -n "$mounts" ] || [ -n "$loopbacks" ]; then
        echo "distro is potentially running - if needed shutdown the distro, and unmount mounted folders"
        echo
        echo "To automatically unmount mount points mentioned below, run \`$script unmount -a $1\`"
        echo
        echo "mount points under $distro_path:"
        echo "${mounts:-Not found}"
        echo "end of mount points"
        echo
        echo "loopback devices under $distro_path:"
        echo "${loopbacks:-Not found}"
        echo "end of loopback devices"
        exit 1
    fi

    if [ "" = "$custom_path" ]; then
        backup_path="$chroot_distro_path/.backup/$1.tar.xz"
        if [ -f "$backup_path" ]; then
            echo "backup already exist, unbackup and try agin"
            exit 1
        fi
        (
            cd "$chroot_distro_path" || exit 1;
            if ! tar -caf "$backup_path" "$distro" 2>/dev/null || true; then
                echo "Error: creating the backup failed"
                exit 5
            fi
        )
    else
        absolute_custom_path="$custom_path"
        if [ "$custom_path" = "${custom_path#/}" ]; then
            # can not have a relative path as current directory will change
            absolute_custom_path="$PWD/$custom_path"
        fi
        (
            cd "$chroot_distro_path" || exit 1;
            if ! tar -caf "$absolute_custom_path" "$distro" 2>/dev/null || true; then
                echo "Error: creating the backup failed"
                exit 5
            fi
        )
    fi
}

chroot_distro_find_archive_common_path() {
    archive_path=$1
    archive_type=${archive_type-$(chroot_distro_check_archive_file_type "$archive_path")}
    if [ "" = "$archive_type" ]; then
        echo "Error: unsupported or corrupt archive" >&2
        exit 5
    fi
    paths_to_check="$(tar -tf "$archive_path" 2>/dev/null)"

    i=1
    prev_path=

    while [ $i -lt 100 ]
    do
        path=$(echo "$paths_to_check" | cut -f1-"$i" -d/ | uniq -u)
        if [ -z "$path" ]; then
            prev_path=$(echo "$paths_to_check" | cut -f1-"$i" -d/ | uniq)
        else
            echo "$prev_path"
            break
        fi
        i=$((i+1))
    done
}

chroot_distro_unbackup() {
    chroot_distro_check_if_supported "$1"

    backup_path="$chroot_distro_path/.backup/$1.tar.xz"
    if [ -f "$backup_path" ]; then
        rm "$backup_path"
    else
        echo "backup not found $1"
        exit 1
    fi
}

chroot_distro_restore() {
    distro="$1"
    custom_backup_path="$2"
    restore_defaults="$3"
    force="$4"
    chroot_distro_check_if_supported "$distro"

    distro_path="$chroot_distro_path/$distro"
    if [ -d "$distro_path" ]; then
        echo "distro already installed , uninstall and try again"
        exit 1
    fi

    if [ "" = "$custom_backup_path" ]; then
        backup_path="$chroot_distro_path/.backup/$1.tar.xz"
    else
        absolute_backup_path="$custom_backup_path"
        if [ "$custom_backup_path" = "${custom_backup_path#/}" ]; then
            # can not have a relative path as current directory may and will change
            absolute_backup_path="$PWD/$custom_backup_path"
        fi
        backup_path="$absolute_backup_path"
    fi

    if [ ! -f "$backup_path" ]; then
        echo "backup not found"
        exit 1
    fi

    common_path="$(chroot_distro_find_archive_common_path "$backup_path")"
    # shellcheck disable=SC2181
    # we want both the output and error code, so need indirection
    if [ $? -ne 0 ]; then
        # Something went wrong with finding the archive common path
        return $?
    fi
    if [ "" = "$common_path" ]; then
        common_path="."
    fi
    rootdir="$( echo "$common_path" | cut -f1 -d/ )"

    archive_type=${archive_type-$(chroot_distro_check_archive_file_type "$backup_path")}
    if [ "" = "$archive_type" ]; then
        echo "Error: unsupported or corrupt archive"
        exit 5
    fi

    if [ "." = "$rootdir" ]; then
        # backup has relative path, restoring is not a problem
        mkdir -p "$distro_path"
        if ! tar -xf "$backup_path" -C "$distro_path/" 2>/dev/null || true; then
            echo "Error: Unpacking the archive failed"
            exit 5
        fi
    elif [ "data" = "$rootdir" ] && [ "yes" = "$force" ]; then
        # Uses old format of backups. Accept only if user has reviewed the content as the backup needs to be
        # applied from root directory, potentially rendering the system unstable and/or be compromised.
        # Also, backup may contain files which will not be visible from running system and will potentially
        # fill the internal storage. There is also possibility of using wrong backup.
        (
            cd /
            if ! tar -xf "$backup_path" 2>/dev/null || true; then
                echo "Error: Unpacking the archive failed"
                exit 5
            fi
        )
    elif [ "data" = "$rootdir" ]; then
        echo "Will restore from root directory, review the contents and use --force."
        echo "Warning: Old style backup. May contain file backups from sdcard and other system mount points."
        echo "Restore may fail if not enough space on internal storage, and restored files from system mount"
        echo "points will be shadowed by system mounts."
        if [ "/$common_path" != "$distro_path" ]; then
            echo "Warning: Backup may be for different distro:"
            echo "- expected common denominator path: $distro_path"
            echo "- archive had following common denominator path: /$common_path"
        fi
        exit 4
    elif [ "$distro" = "$rootdir" ]; then
        # new format backups
        (
            cd "$chroot_distro_path" || exit 1;
            if ! tar -xf "$backup_path" 2>/dev/null || true; then
                echo "Error: Unpacking the archive failed"
                exit 5
            fi
        )
    else
        echo "Backup may be for wrong distro (root directory $rootdir), review the backup before proceeding"
        exit 4
    fi

    chroot_distro_mount_system_points "$distro_path" no

    if [ "yes" = "$restore_defaults" ]; then
        resolvconf="$distro_path"/etc/resolv.conf
        if [ -L "$resolvconf" ] && [ ! -f "$resolvconf" ]; then
            # broken link
            rm "$resolvconf"
        fi
        echo "nameserver 8.8.8.8" > "$resolvconf"
        echo "nameserver 8.8.4.4" >> "$resolvconf"
        cp /etc/hosts "$distro_path"/etc/hosts
        chroot "$distro_path" /sbin/groupadd -g 3003 aid_inet 2>/dev/null || true
        chroot "$distro_path" /sbin/groupadd -g 3004 aid_net_raw 2>/dev/null || true
        chroot "$distro_path" /sbin/groupadd -g 1003 aid_graphics 2>/dev/null || true
        chroot "$distro_path" /sbin/usermod -g 3003 -G 3003,3004 -a _apt 2>/dev/null || true
        chroot "$distro_path" /sbin/usermod -G 3003 -a root 2>/dev/null || true
        timezone="$(getprop persist.sys.timezone)"
        chroot "$distro_path" /bin/ln -sf /usr/share/zoneinfo/$timezone /etc/localtime 2>/dev/null || true
        unset timezone
        chroot "$distro_path" /sbin/locale-gen en_US.UTF-8 2>/dev/null || true
    fi
    chroot_distro_jail "$distro_path"
}

chroot_distro_unmount() {
    distro="$1"
    force="$2"
    all="$3"
    chroot_distro_check_if_supported "$distro" 

    distro_path="$chroot_distro_path/$distro"
    if [ ! -d "$distro_path" ]; then
        echo "$distro not installed"
        exit 1
    fi

    if [ "yes" = "$all" ]; then
        if [ "yes" = "$force" ]; then
            # first try to kill all processes before trying to unmount anything
            # note: close from earlier to later processes to ensure that no new worker processes are created during killing
            chroot_distro_find_processes_with_open_files "$distro_path/" | xargs -I {} kill {} > /dev/null 2>&1
        fi
        # before normal unmounts, go through all loopback devices
        # note: in reverse order in case there is loopback mount from inside the loopback mount (quite contrived case but just in case...)
        chroot_distro_find_all_loopback_mount_points "$distro_path/" | sort -r | xargs -I {} umount {} > /dev/null 2>&1
        # try to unmount everything found
        # note: using reverse sort to ensure that mounts residing deeper in the file system will be unmmounted first
        chroot_distro_find_all_mount_points "$distro_path/" | sort -r | xargs -I {} umount {} > /dev/null 2>&1
    else
        chroot_distro_unmount_system_points "$distro_path" "$force"
    fi

    if [ "yes" = "$all" ]; then
        mounts=$(mount | grep -F "$distro_path")
        loopbacks=$(losetup -a | grep -F "$distro_path")
        open_files=$(lsof | grep -F "$distro_path")
        # as all mount points are being unmounted, no need to test for system mount points separately
        system_mount_points_mounted=1
        mode=all
    else
        mounts=$(mount | grep -F "$distro_path" | chroot_distro_output_system_mount_point_paths "$distro_path")
        loopbacks=$(losetup -a | grep -F "$distro_path" | chroot_distro_output_system_mount_point_paths "$distro_path")
        open_files=$(lsof | grep -F "$distro_path" | chroot_distro_output_system_mount_point_paths "$distro_path")
        chroot_distro_check_if_system_points_mounted "$distro_path"
        system_mount_points_mounted=$?
        mode=system
    fi
    if [ "" != "$mounts" ] || [ "" != "$loopbacks" ] || [ "" != "$open_files" ] || [ "0" = "$system_mount_points_mounted" ]; then
        chroot_distro_list_unmount_issues "$distro_path" 'unmount' "$mode" "$force" "$mounts" "$loopbacks" "$open_files"
        exit 1
    fi
}

chroot_distro_command() {
    chroot_distro_check_if_supported "$1"

    command="$2"

    distro_path="$chroot_distro_path/$1"
    if [ ! -d "$distro_path" ]; then
        echo "$1 not installed"
        exit 1
    fi

    chroot_distro_mount_system_points "$distro_path" no

    chroot_distro_jail "$distro_path" "$command"
}

chroot_distro_login() {
    chroot_distro_check_if_supported "$1"

    distro_path="$chroot_distro_path/$1"
    if [ ! -d "$distro_path" ]; then
        echo "$1 not installed"
        exit 1
    fi

    chroot_distro_mount_system_points "$distro_path" no

    chroot_distro_jail "$distro_path"
}

chroot_distro_invalid_parameters() {
    echo "$script - $1"
    echo "try '$script help' for more information"
    exit 2
}

chroot_distro_user_check_parameters() {
    chroot_distro_invalid_parameters "unknonwn parameters"
}

chroot_distro_missing_distro() {
    chroot_distro_invalid_parameters "missing distro"
}

if [ $# -eq 0 ]; then
    chroot_distro_help
    exit
fi

command=$1
shift

if [ "$command" = "help" ]; then
    PARSED=$(getopt --options= --longoptions= --name "$0" -- "$@") || exit 2
    chroot_distro_help
elif [ "$command" = "list" ]; then
    PARSED=$(getopt --options= --longoptions= --name "$0" -- "$@") || exit 2
    eval set -- "$PARSED"
    while true; do
        case "$1" in
            --)
                shift
                break
                ;;
            *)
                echo "Programming error"
                exit 3
                ;;
        esac
    done
    if [ $# -ne 0 ]; then
        chroot_distro_user_check_parameters
    fi
    chroot_distro_list
elif [ "$command" = "download" ]; then
    PARSED=$(getopt --options= --longoptions= --name "$0" -- "$@") || exit 2
    eval set -- "$PARSED"
    while true; do
        case "$1" in
            --)
                shift
                break
                ;;
            *)
                echo "Programming error"
                exit 3
                ;;
        esac
    done
    if [ $# -eq 0 ]; then
        chroot_distro_missing_distro
    elif [ $# -ne 1 ]; then
        chroot_distro_user_check_parameters
    fi
    chroot_distro_warn_if_unsupported_busybox
    chroot_distro_download "$1"
elif [ "$command" = "redownload" ]; then
    PARSED=$(getopt --options= --longoptions= --name "$0" -- "$@") || exit 2
    eval set -- "$PARSED"
    while true; do
        case "$1" in
            --)
                shift
                break
                ;;
            *)
                echo "Programming error"
                exit 3
                ;;
        esac
    done
    if [ $# -eq 0 ]; then
        chroot_distro_missing_distro
    elif [ $# -ne 1 ]; then
        chroot_distro_user_check_parameters
    fi
    chroot_distro_download "$1"
elif [ "$command" = "delete" ]; then
    PARSED=$(getopt --options= --longoptions= --name "$0" -- "$@") || exit 2
    eval set -- "$PARSED"
    while true; do
        case "$1" in
            --)
                shift
                break
                ;;
            *)
                echo "Programming error"
                exit 3
                ;;
        esac
    done
    if [ $# -eq 0 ]; then
        chroot_distro_missing_distro
    elif [ $# -ne 1 ]; then
        chroot_distro_user_check_parameters
    fi
    chroot_distro_delete "$1"
elif [ "$command" = "install" ]; then
    PARSED=$(getopt --options=a --longoptions=android --name "$0" -- "$@") || exit 2
    eval set -- "$PARSED"
    android=no
    while true; do
        case "$1" in
            -a|--android)
                android=yes
                shift
                ;;
            --)
                shift
                break
                ;;
            *)
                echo "Programming error"
                exit 3
                ;;
        esac
    done
    if [ $# -eq 0 ]; then
        chroot_distro_missing_distro
    elif [ $# -ne 1 ]; then
        chroot_distro_user_check_parameters
    fi
    chroot_distro_warn_if_unsupported_busybox
    chroot_distro_install "$1" "$android"
elif [ "$command" = "uninstall" ]; then
    PARSED=$(getopt --options=f --longoptions=force --name "$0" -- "$@") || exit 2
    eval set -- "$PARSED"
    force=no
    while true; do
        case "$1" in
            -f|--force)
                force=yes
                shift
                ;;
            --)
                shift
                break
                ;;
            *)
                echo "Programming error"
                exit 3
                ;;
        esac
    done
    if [ $# -eq 0 ]; then
        chroot_distro_missing_distro
    elif [ $# -ne 1 ]; then
        chroot_distro_user_check_parameters
    fi
    chroot_distro_uninstall "$1" "$force" "$command"
elif [ "$command" = "reinstall" ]; then
    OPTS=af LONGOPTS=android,force
    PARSED=$(getopt --options=$OPTS --longoptions=$LONGOPTS --name "$0" -- "$@") || exit 2
    eval set -- "$PARSED"
    android=no
    force=no
    while true; do
        case "$1" in
            -a|--android)
                android=yes
                shift
                ;;
            -f|--force)
                force=yes
                shift
                ;;
            --)
                shift
                break
                ;;
            *)
                echo "Programming error"
                exit 3
                ;;
        esac
    done
    if [ $# -eq 0 ]; then
        chroot_distro_missing_distro
    elif [ $# -ne 1 ]; then
        chroot_distro_user_check_parameters
    fi
    chroot_distro_uninstall "$1" "$force" "$command"
    chroot_distro_install "$1" "$android"
elif [ "$command" = "backup" ]; then
    PARSED=$(getopt --options= --longoptions= --name "$0" -- "$@") || exit 2
    eval set -- "$PARSED"
    while true; do
        case "$1" in
            --)
                shift
                break
                ;;
            *)
                echo "Programming error"
                exit 3
                ;;
        esac
    done
    if [ $# -eq 0 ]; then
        chroot_distro_missing_distro
    elif [ $# -gt 2 ]; then
        chroot_distro_user_check_parameters
    fi
    chroot_distro_backup "$1" "$2"
elif [ "$command" = "unbackup" ]; then
    PARSED=$(getopt --options= --longoptions= --name "$0" -- "$@") || exit 2
    eval set -- "$PARSED"
    while true; do
        case "$1" in
            --)
                shift
                break
                ;;
            *)
                echo "Programming error"
                exit 3
                ;;
        esac
    done
    if [ $# -eq 0 ]; then
        chroot_distro_missing_distro
    elif [ $# -ne 1 ]; then
        chroot_distro_user_check_parameters
    fi
    chroot_distro_unbackup "$1"
elif [ "$command" = "restore" ]; then
    OPTS=d LONGOPTS=default,force
    PARSED=$(getopt --options=$OPTS --longoptions=$LONGOPTS --name "$0" -- "$@") || exit 2
    eval set -- "$PARSED"
    restore_defaults=no
    force=no
    while true; do
        case "$1" in
            -d|--default)
                restore_defaults=yes
                shift
                ;;
            --force)
                force=yes
                shift
                ;;
            --)
                shift
                break
                ;;
            *)
                echo "Programming error"
                exit 3
                ;;
        esac
    done
    if [ $# -eq 0 ]; then
        chroot_distro_missing_distro
    elif [ $# -gt 2 ]; then
        chroot_distro_user_check_parameters
    fi
    chroot_distro_restore "$1" "$2" "$restore_defaults" "$force"
elif [ "$command" = "command" ]; then
    PARSED=$(getopt --options= --longoptions= --name "$0" -- "$@") || exit 2
    eval set -- "$PARSED"
    while true; do
        case "$1" in
            --)
                shift
                break
                ;;
            *)
                echo "Programming error"
                exit 3
                ;;
        esac
    done
    if [ $# -eq 0 ]; then
        chroot_distro_missing_distro
    elif [ $# -eq 1 ]; then
        chroot_distro_invalid_parameters "program missing"
    elif [ $# -ne 2 ]; then
        chroot_distro_user_check_parameters
    fi
    chroot_distro_command "$1" "$2"
elif [ "$command" = "login" ]; then
    PARSED=$(getopt --options= --longoptions= --name "$0" -- "$@") || exit 2
    eval set -- "$PARSED"
    while true; do
        case "$1" in
            --)
                shift
                break
                ;;
            *)
                echo "Programming error"
                exit 3
                ;;
        esac
    done
    if [ $# -eq 0 ]; then
        chroot_distro_missing_distro
    elif [ $# -ne 1 ]; then
        chroot_distro_user_check_parameters
    fi
    chroot_distro_login "$1"
elif [ "$command" = "unmount" ]; then
    PARSED=$(getopt --options=fa --longoptions=force,all --name "$0" -- "$@") || exit 2
    eval set -- "$PARSED"
    force=no
    all=no
    while true; do
        case "$1" in
            -f|--force)
                force=yes
                shift
                ;;
            -a|--all)
                all=yes
                shift
                ;;
            --)
                shift
                break
                ;;
            *)
                echo "Programming error"
                exit 3
                ;;
        esac
    done
    if [ $# -eq 0 ]; then
        chroot_distro_missing_distro
    elif [ $# -ne 1 ]; then
        chroot_distro_user_check_parameters
    fi
    chroot_distro_unmount "$1" "$force" "$all"
else
    chroot_distro_invalid_parameters "invalid command $command"
fi
