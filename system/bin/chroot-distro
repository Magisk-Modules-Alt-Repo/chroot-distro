#!/system/bin/sh
#
# Copyright 2024 Yasser Null
#
# Code is licensed under terms of GNU GPL v3, see LICENSE file
# for the full terms.

if [ -n "${chroot_distro_log+x}" ]; then
  set -e
  set -x
  # shellcheck disable=SC3047
  trap 'echo "Error at line $LINENO"' ERR
fi

chroot_distro_path="/data/local/chroot-distro"
script=$(basename "$0")

user_id=$(id -u)
if [ "${user_id}" -ne 0 ]; then
    echo "Root access required."
    exit 1
fi

architecture=$(uname -m)

case "${architecture}" in
    aarch64|arm64) hardware_machine="arm64" ;;
    arm|armel|armhf|armhfp|armv7|armv7l|armv7a|armv8l) hardware_machine="armhf" ;;
    386|i386|i686|x86) hardware_machine="i386" ;;
    amd64|x86_64) hardware_machine="amd64" ;;
    *) echo "Unsupported machine hardware: ${architecture}"; exit 1 ;;
esac

supported_distros="alpine archlinux artix debian deepin fedora manjaro openkylin opensuse pardus ubuntu void kali parrot backbox centos centos_stream rocky adelie chimera gentoo"

check_env=''
if [ $# -ge 1 ] && [ "env" = "$1" ]; then
    check_env=true
fi

hash=$(md5sum "$0" | cut -d " " -f1)

if [ "" = "${check_env}" ]; then
    : # do nothing
elif [ -e /data/adb/modules/chroot-distro ]; then
    echo "Script: $0"
    if cmp -s "$0" /data/adb/modules/chroot-distro/system/bin/chroot-distro; then
        (
            module_prop=$(cat /data/adb/modules/chroot-distro/module.prop)
            echo "${module_prop}" | while read -r row; do
                field=$(echo "${row}" | cut -d "=" -f 1 )
                value=$(echo "${row}" | cut -d "=" -f 2 )
                case "${field}" in
                    version) echo "Version: ${value}" ;;
                    versionCode) echo "Versioncode: $value" ;;
                    *) echo "Unknown field: ${field}";;
                esac
            done
            echo "md5 hash: ${hash}"
        )
    else
        echo "Not matching installed version, md5 hash: ${hash}"
    fi
else
    echo "Script: $0"
    echo "Unknown version, md5 hash: ${hash}"
fi

if [ "" != "${check_env}" ]; then
    echo "Toybox version: $(toybox --version)"
fi

busyboxpath="$(command -v busybox 2> /dev/null || true)"
if [ -z "$busyboxpath" ]; then
    busyboxpath=''
    if [ -e /data/adb ]; then
        # try harder... -- thanks for the pointer, @osm0sis
        if [ "" != "$check_env" ]; then
            echo 'Checking for hidden Busyboxes'
        fi
        for possiblepath in /data/adb/modules/busybox-ndk/system/*/busybox /data/adb/magisk/busybox /data/adb/ksu/bin/busybox /data/adb/ap/bin/busybox; do
            if [ -f "$possiblepath" ]; then
                busyboxpath="$possiblepath"
                break
            fi
        done;
    fi
    if [ "" = "$check_env" ] && [ "" = "$busyboxpath" ]; then
        echo "busybox not found, install Busybox for Android NDK and try again"
        echo "Run '$script env' for extra information"
        exit 1
    fi
fi

if [ "" != "$check_env" ]; then
    echo "busybox => '$busyboxpath'"
    if [ "" != "$busyboxpath" ]; then
        echo "Busybox version: $($busyboxpath | head -n1)"
    fi
fi

unsupported_busybox=''
case "$busyboxpath" in
    /bin/*) ;; # assume that it is ok (either old android, or linux), nothing to do
    /system/*)
        ndk_path=/system/xbin/busybox
        if [ "$busyboxpath" != "$ndk_path" ] && [ -e "$ndk_path" ]; then
            # force use of Busybox for Android NDK in the case there is conflicting versions
            if [ "" != "$check_env" ]; then
                echo "Forcing Busybox path from '$busyboxpath' to '$ndk_path'"
                echo "Forced Busybox version: $($ndk_path | head -n1)"
            fi
            busyboxpath="$ndk_path"
        fi
    ;;
    /data/adb/modules/busybox-ndk/system/*) ;; # hidden Busybox for Android NDK, nothing to do
    /data/adb/magisk/*) unsupported_busybox=true ;; # Magisk without Busybox for Android NDK installed
    /usr/bin/*) ;; # running linux, assume that all is ok, nothing to do
    /data/adb/ksu/bin/*) unsupported_busybox=true ;; # KernelSU without Busybox for Android NDK installed
    /data/adb/ap/bin/*) unsupported_busybox=true ;; # APatch without Busybox for Android NDK installed
    *)
        if [ "" = "$check_env" ]; then
            echo "busybox not found from the expected path, ensure that Busybox for Android NDK has been installed and try again"
            echo "Run '$script env' for extra information"
            exit 1
        fi
    ;;
esac

busyboxdir="$(dirname "$busyboxpath")"
can_use_busyboxdir=true
if [ "" = "$busyboxpath" ]; then
    # not found
    can_use_busyboxdir=''
elif [ "/system/bin" = "$busyboxdir" ]; then
    # would use Toybox version always, skip
    can_use_busyboxdir=''
elif [ "/usr/bin" = "$busyboxdir" ]; then
    # would use full/normal chroot command, skip to ensure consistent test environment
    can_use_busyboxdir=''
fi
if [ "" != "$can_use_busyboxdir" ] &&  [ -e "$busyboxdir"/chroot ]; then
    # Use chroot from the expected Busybox
    chrootpath="$(dirname "$busyboxpath")"/chroot
elif [ -e /system/xbin/chroot ]; then
    # Use a Busybox version
    chrootpath=/system/xbin/chroot
elif [ -e /system/bin/chroot ]; then
    # Fall back to Toybox version
    chrootpath=/system/bin/chroot
else
    # don't want to use a random chroot to ensure it doesn't affect the jail
    chrootpath=''
fi
unset can_use_busyboxdir
unset busyboxdir

if [ "" = "$check_env" ] && [ "" = "$chrootpath" ]; then
    echo "chroot not found from the expected path, ensure that Busybox for Android NDK has been installed and try again"
    echo "Run '$script env' for extra information"
    exit 1
fi

busyboxlsofcaller=''
busyboxlsof=''
if [ "" != "$busyboxpath" ] && "$busyboxpath" lsof > /dev/null 2>&1 || true; then
    # prefer the version provided by the found busybox binary
    busyboxlsofcaller=true
    busyboxlsof=true
    lsofpath='busybox lsof'
elif [ -e /system/xbin/lsof ]; then
    # busybox version
    lsofpath=/system/xbin/lsof
    busyboxlsof=true
elif [ -e /system/bin/lsof ]; then
    # toybox version
    lsofpath=/system/bin/lsof
else
    # don't want to use random lsof as it may not work (or has different output)
    # in this case user has to manually run the command
    lsofpath=''
fi

# ensure that the expected version of busybox is used
busybox() { "$busyboxpath" "$@"; }

# Toybox uname does not support -p
uname() {
    if [ "" != "$busyboxpath" ]; then
        busybox uname "$@";
    else
        # fall back to defaults to ensure at least some output
        uname -a
    fi
}

# ensure that busybox version of getopt is used
getopt() { busybox getopt "$@"; }

# ensure that busybox version of tar is used
tar() { busybox tar "$@"; }

# ensure that busybox version of wget is used
wget() { busybox wget "$@"; }

# ensure that correct version of chroot is used
chroot() { "$chrootpath" "$@"; }

lsof() {
    if [ "" != "$busyboxlsofcaller" ]; then
        busybox lsof
    elif [ "" = "$lsofpath" ]; then
        # lsof is optional, no output
        :
    else
        "$lsofpath";
    fi
}

if [ "" != "$check_env" ]; then
    echo "chroot => '$chrootpath'"
    if [ "" = "$chrootpath" ]; then
        echo "chroot found in PATH (but not used) => '$(command -v chroot 2> /dev/null)'"
    fi
    echo "lsof => '$lsofpath'"
    if [ "" = "$lsofpath" ]; then
        echo "lsof found in PATH (but not used) => '$(command -v lsof 2> /dev/null)'"
    fi
    if [ ! -e /data/adb ]; then
        echo 'Could not determine the type of root solution installed'
    elif [ -e /data/adb/magisk ]; then
        case "$hardware_machine" in
            *64)
                if [ -e /data/adb/magisk/magisk64 ]; then
                    magiskbin=/data/adb/magisk/magisk64
                elif [ -e /data/adb/magisk/magisk ]; then
                    magiskbin=/data/adb/magisk/magisk
                fi
                if [ "" != "$magiskbin" ]; then
                    magisk_version=$($magiskbin -v)
                else
                    magisk_version=Unknown
                fi
            ;;
            *)
                if [ -e /data/adb/magisk/magisk32 ]; then
                    magiskbin=/data/adb/magisk/magisk32
                elif [ -e /data/adb/magisk/magisk ]; then
                    magiskbin=/data/adb/magisk/magisk
                fi
                if [ "" != "$magiskbin" ]; then
                    magisk_version=$($magiskbin -v)
                else
                    magisk_version=Unknown
                fi
            ;;
        esac
        echo "Magisk installed ($magisk_version)"
    elif [ -e /data/adb/ksu ]; then
        # would be nice if the version information could be provided, patches welcome
        echo "KernelSU installed (Unknown)"
    elif [ -e /data/adb/ap ]; then
        # Verify the APatch daemon executable exists
        if [ -e /data/adb/ap/bin/apd ]; then
            # Set path to APatch daemon and get its version
            apatchbin=/data/adb/ap/bin/apd
            binary_version=$("$apatchbin" -V | awk '{print $2}')

            # I can't find any method or way, with no documentation whatsoever to get the kernel patch version
            # So I had to do it in a ughh fucking crude way by getting the value from the log and calculating it
            if [ -e /data/adb/ap/log/dmesg.log ]; then
                # Extract the KernelPatch version hex value from log (e.g., "b01")
                # $6 refers to the 6th field in the log line "KP KernelPatch Version: b01"
                kp_version=$(grep "KP KernelPatch Version:" /data/adb/ap/log/dmesg.log | awk '{print $6}')

                # Check if we successfully got a version number
                if [ -z "$kp_version" ]; then
                    apatch_version="Unknown"
                else
                    # Clean up the hex value:
                    # - Remove '0x' prefix if present using sed
                    # - Convert to lowercase for consistency
                    clean_hex=$(echo "$kp_version" | sed 's/^0x//i' | tr '[:upper:]' '[:lower:]')
                    
                    # Convert hex to decimal
                    # Format: 0xb01 = 2817 (decimal)
                    # If conversion fails, dec_value will be empty
                    dec_value=$(printf '%d' "0x$clean_hex" 2>/dev/null) || dec_value=""

                    if [ -n "$dec_value" ]; then
                        # Get length of hex string to handle different formats
                        hex_len=${#clean_hex}
                        
                        # Handle small hex values (≤ 2 digits)
                        if [ "$hex_len" -le 2 ]; then
                            major=0
                            minor=0
                            patch="$dec_value"
                        else
                            # Extract version components using bitwise operations:
                            # For hex b01 (2817 decimal):
                            # major: bits 15-12 (0 in this case)
                            # minor: bits 11-8  (11 in this case)
                            # patch: bits 7-0   (1 in this case)
                            major=$(( dec_value >> 12 & 15 ))  # Get highest 4 bits
                            minor=$(( dec_value >> 8 & 15 ))   # Get next 4 bits
                            patch=$(( dec_value & 255 ))       # Get lowest 8 bits
                        fi
                        
                        # Format version string (e.g., "0.11.1")
                        version_string="$major.$minor.$patch"
                        # Combine with binary version (e.g., "0.11.1 [11023]")
                        apatch_version="$version_string [$binary_version]"
                    else
                        apatch_version="Unknown"
                    fi
                fi
            else
                apatch_version="Unknown"
            fi
        else
            apatch_version="Unknown"
        fi
        # Final result (e.g., "APatch installed (0.11.1 [11023])")
        # I haven't tested it against older versions yet, but I'm sure it will works somehow and hopefully for the future versions as well
        echo "APatch installed ($apatch_version)"
    else
        echo 'Unknown root solution, possible candidates:'
        for candidate in /data/adb/*; do
            if [ -d "$candidate" ]; then
                dirname=$(basename "$candidate")
                case "$dirname" in
                    modules) ;; # not interested
                    post-fs-data.d) ;; # not interested
                    service.d) ;; # not interested
                    *) echo "$dirname" ;;
                esac
            fi
        done
        echo 'list end'
    fi
    if [ ! -e /data/adb ]; then
        echo 'Could not determine if Busybox for Android NDK Magisk module is installed'
    elif [ -e /data/adb/modules/busybox-ndk ]; then
        echo 'Busybox for Android NDK Magisk module installed'
    else
        echo 'Busybox for Android NDK Magisk module not installed'
    fi
    # don't want machine name, otherwise -a would be easiest
    if [ "unknown" != "$(uname -p)" ]; then
        uname -s -r -v -m -p -i -o
    else
        uname -s -r -v -m -o
    fi
    echo "PATH=$PATH"
    # check run successfully, bail out
    exit 0
fi

getopt --test > /dev/null && true
if [ $? -ne 4 ]; then
    # shellcheck disable=SC2016
    echo 'I'\''m sorry, `getopt --test` failed in this environment.'
    echo "Run '$script env' for extra information"
    exit 1
fi

if ! tar --help 2>&1 | grep -q -- "-J" ; then
    echo 'Your Busybox tar does not support xz compression. Update your busybox!'
    exit 1
fi

mkdir -p "$chroot_distro_path" "$chroot_distro_path/.rootfs" "$chroot_distro_path/.backup"
suid_file="$chroot_distro_path/suid"

fixsuid() {
    suid_val=$(cat "$suid_file" 2>/dev/null)

    # If the argument is "enable", write 1 to the suid file
    if [ "$1" = "enable" ]; then
        if [ "$suid_val" != "1" ]; then
            echo 1 > "$suid_file" || true
        else
            echo "fixsuid is enabled already"
        fi
    # If the argument is "disable", write 0 to the suid file
    elif [ "$1" = "disable" ]; then
        if [ "$suid_val" != "0" ]; then
            echo 0 > "$suid_file" || true
        else
            echo "fixsuid is disabled already"
        fi
    fi

    # Re-read the value from the suid file
    suid_val=$(cat "$suid_file" 2>/dev/null)

    # If suid is disabled (0), remount /data with nosuid and nodev if needed
    if [ "$suid_val" = "0" ]; then
        if grep -q '^/dev' /proc/mounts | grep -q ' /data ' | grep -wq "suid" || true; then
            mount -o remount,nodev,nosuid /data || true || echo "Failed to remount /data with nosuid"
        fi
    # If suid is enabled (1), remount /data with suid and dev if needed
    elif [ "$suid_val" = "1" ]; then
        if grep -q '^/dev' /proc/mounts | grep -q ' /data ' | grep -wq "nosuid" || true; then
            mount -o remount,dev,suid /data || true || echo "Failed to remount /data with suid"
        fi
    fi
}

# Check if the suid file exists; if not, create it and set value to 1
if [ ! -f "$chroot_distro_path/suid" ]; then
    fixsuid enable
fi

fixsuid

ram_bind_file="$chroot_distro_path/ram_bind"
ram_bind_val=""

ram_bind() {
    ram_bind_val=$(cat "$ram_bind_file" 2>/dev/null)

    # If the argument is "enable", write 1 to the ram bind file
    if [ "$1" = "enable" ]; then
        if [ "$ram_bind_val" != "1" ]; then
            echo 1 > "$ram_bind_file" || true
        else
            echo "ram bind is enabled already"
        fi
    # If the argument is "disable", write 0 to the ram bind file
    elif [ "$1" = "disable" ]; then
        if [ "$ram_bind_val" != "0" ]; then
            echo 0 > "$ram_bind_file" || true
        else
            echo "ram bind is disabled already"
        fi
    fi

    # Re-read the value from the ram bind file
    ram_bind_val=$(cat "$ram_bind_file" 2>/dev/null)

}

if [ ! -f "$chroot_distro_path/ram_bind" ]; then
    ram_bind enable
fi

ram_bind

android_bind_file="$chroot_distro_path/android_bind"
android_bind_val=""

android_bind() {
    android_bind_val=$(cat "$android_bind_file" 2>/dev/null)

    # If the argument is "enable", write 1 to the android bind file
    if [ "$1" = "enable" ]; then
        if [ "$android_bind_val" != "1" ]; then
            echo 1 > "$android_bind_file" || true
        else
            echo "android bind is enabled already"
        fi
    # If the argument is "disable", write 0 to the android bind file
    elif [ "$1" = "disable" ]; then
        if [ "$android_bind_val" != "0" ]; then
            echo 0 > "$android_bind_file" || true
        else
            echo "android bind is disabled already"
        fi
    fi

    # Re-read the value from the android bind file
    android_bind_val=$(cat "$android_bind_file" 2>/dev/null)

}

if [ ! -f "$chroot_distro_path/android_bind" ]; then
    android_bind enable
fi

android_bind

system_points="/dev /sys /proc /dev/pts /sdcard"
for file in "/storage"/*; do
    system_points="$system_points $file"
done

chroot_distro_warn_if_unsupported_busybox() {
    if [ "" != "$unsupported_busybox" ]; then
        echo "Warning: You are using Magisk/KernelSU/APatch without Busybox for Android NDK installed."
        echo "You may experience bugs as this is community supported environment."
    fi
}

chroot_distro_help() {
    echo "$script : install linux distributions

usage :

$script help - for more information
$script env - output debug information about environment
$script list - list of available linux distributions

$script fixsuid <enable|disable> - force suid option on /data mount (default: enable) 
$script ram-bind <enable|disable> - Binds some paths in the distro to RAM for performance improvement (default: enable)
$script android-bind <enable|disable> - Bind all Android root directories, which are not bound by default (default: enable) 

$script download <distro> - download rootfs
$script redownload <distro> - redownload rootfs
$script delete <distro> - delete rootfs

$script install <distro> - install distro
$script reinstall <distro> [-f|--force] - reinstall distro
    '-f|--force'    Force closing open files (closes the process accessing them)
                    and/or unmounting active mounts. Use with care.
$script uninstall <distro> [-f|--force] - uninstall distro
    '-f|--force'    Force closing open files (closes the process accessing them)
                    and/or unmounting active mounts. Use with care.

$script unmount <distro|all> [-f|--force] [-a|--all] - unmount (system) mount points from distro
    '-f|--force'    Force closing open files (closes the process accessing them)
                    and/or unmounting active mounts which prevents (system) mount points
                    from unmounting. Use with care.
    '-a|--all'      Instead of unmounting only system mount points, will try to unmount
                    all found mount points, be it a normal mount point or a loopback mount point.

$script backup <distro> [<path>] - backup distro
    <path>          Custom path for backup location
$script restore <distro> [-d|--default] [--force] [<path>] - restore distro
    <path>          Custom path for backup location
    '-d|--default'  restore default settings (note: only those set during install)
    '--force'       Force restore even if may cause unintended side-effects
$script unbackup <distro> - delete backup from default location

$script command <distro> <command> - run command
$script login <distro> - login to distro
"

    chroot_distro_warn_if_unsupported_busybox
}

chroot_distro_list_item() {
    if [ -f "$chroot_distro_path/.rootfs/$1.tar.xz" ]; then
        echo "Downloaded : Yes"
    else
        echo "Downloaded : No"
    fi
    if [ -d "$chroot_distro_path/$1/" ]; then
        echo "Installed: Yes"
    else
        echo "Installed: No"
    fi
    if [ -f "$chroot_distro_path/.backup/$1.tar.xz" ]; then
        echo "Backup : Yes"
    else
        echo "Backup : No"
    fi
    echo
}

# Notice: if you change one of the base urls, remember to check that the full download link is still correct
# as some of the full urls may have the version information multiple times
proot_distro_rootfs_base_url=https://github.com/termux/proot-distro/releases/download 
anlinux_rootfs_base_url=https://github.com/EXALAB/Anlinux-Resources
# proot distro rootfs: 
debian_rootfs_base_url_prootdistro=$proot_distro_rootfs_base_url/v4.7.0/
manjaro_rootfs_base_url=$proot_distro_rootfs_base_url/v4.14.1/
openkylin_rootfs_base_url=$proot_distro_rootfs_base_url/v4.10.0/
pardus_rootfs_base_url=$proot_distro_rootfs_base_url/v4.6.0/
opensuse_rootfs_base_url=$proot_distro_rootfs_base_url/v4.6.0/
artix_rootfs_base_url=$proot_distro_rootfs_base_url/v4.6.0/
deepin_rootfs_base_url=$proot_distro_rootfs_base_url/v4.16.0/
rocky_rootfs_base_url=$proot_distro_rootfs_base_url/v4.20.0/
# Official rootfs: 
ubuntu_rootfs_base_url=https://cdimage.ubuntu.com/ubuntu-base/releases/
kali_rootfs_base_url=http://kali.download/nethunter-images/
alpine_rootfs_base_url=http://dl-cdn.alpinelinux.org/alpine/latest-stable/releases/
void_rootfs_base_url=https://repo-default.voidlinux.org/live/
archlinux_rootfs_base_url_arm=http://ca.us.mirror.archlinuxarm.org/os/
archlinux_rootfs_base_url=https://mirrors.ocf.berkeley.edu/archlinux/iso/latest/
adelie_rootfs_base_url=https://distfiles.adelielinux.org/adelie/1.0-beta6/iso/
gentoo_rootfs_base_url=https://distfiles.gentoo.org/releases/
chimera_rootfs_base_url=https://repo.chimera-linux.org/live/
# AnLinux rootfs: 
debian_rootfs_base_url_anlinux=$anlinux_rootfs_base_url/raw/master/Rootfs/Debian/
parrot_rootfs_base_url=$anlinux_rootfs_base_url/raw/master/Rootfs/Parrot/
backbox_rootfs_base_url=$anlinux_rootfs_base_url/raw/master/Rootfs/BackBox/
centos_rootfs_base_url=$anlinux_rootfs_base_url/raw/master/Rootfs/CentOS/
centos_stream_rootfs_base_url=$anlinux_rootfs_base_url/raw/master/Rootfs/CentOS_Stream/

chroot_distro_list() {
    echo "Ubuntu : ubuntu"
    chroot_distro_list_item ubuntu

    echo "Kali Linux : kali"
    chroot_distro_list_item kali

    echo "Debian : debian"
    chroot_distro_list_item debian

    echo "Parrot OS : parrot"
    chroot_distro_list_item parrot

    echo "Alpine Linux : alpine"
    chroot_distro_list_item alpine

    echo "Void Linux : void"
    chroot_distro_list_item void

    if [ "$hardware_machine" != "i386" ]; then
        echo "Arch Linux : archlinux"
        chroot_distro_list_item archlinux
    fi

    if [ "$hardware_machine" = "arm64" ]; then
        echo "Artix Linux : artix"
        chroot_distro_list_item artix
    fi

    if [ "$hardware_machine" = "arm64" ] || [ "$hardware_machine" = "amd64" ]; then
        echo "Deepin : deepin"
        chroot_distro_list_item deepin

        echo "Fedora : fedora"
        chroot_distro_list_item fedora

        echo "OpenKylin : openkylin"
        chroot_distro_list_item openkylin

        echo "CentOS : centos"
        chroot_distro_list_item centos

        echo "CentOS Stream : centos_stream"
        chroot_distro_list_item centos_stream

        echo "Rocky Linux : rocky"
        chroot_distro_list_item rocky

        echo "Chimera Linux : chimera"
        chroot_distro_list_item chimera
    fi

    if [ "$hardware_machine" = "arm64" ]; then
        echo "Manjaro : manjaro"
        chroot_distro_list_item manjaro
    fi

    if [ "$hardware_machine" != "armhf" ]; then
        echo "Pardus : pardus"
        chroot_distro_list_item pardus
    fi

    echo "openSUSE : opensuse"
    chroot_distro_list_item opensuse

    echo "BackBox : backbox"
    chroot_distro_list_item backbox

    echo "Adélie Linux : adelie"
    chroot_distro_list_item adelie

    echo "Gentoo Linux : gentoo"
    chroot_distro_list_item gentoo
}

chroot_distro_download() {
    distro="$1"
    if [ "$distro" = "ubuntu" ]; then
        distro_name='Ubuntu'
        if [ "$hardware_machine" = "i386" ] || [ "$hardware_machine" = "arm64" ] || [ "$hardware_machine" = "armhf" ] || [ "$hardware_machine" = "amd64" ]; then
            echo "[1] ubuntu trusty 14.04"
            echo "[2] ubuntu xenial 16.04"
            echo "[3] ubuntu bionic 18.04"
        fi
        if [ "$hardware_machine" != "i386" ]; then
            echo "[4] ubuntu focal 20.04"
            echo "[5] ubuntu jammy 22.04"
            echo "[6] ubuntu noble 24.04"
            echo "[7] ubuntu oracular 24.10"
            echo "[8] ubuntu plucky 25.04"
        fi
        while true; do
            printf "Enter a number (1-8, or 'q' to quit): " 
            read -r number
            case "$number" in
                1) release="trusty"; break;;
                2) release="xenial"; break;;
                3) release="bionic"; break;;
                4) release="focal"; break;;
                5) release="jammy"; break;;
                6) release="noble"; break;;
                7) release="oracular"; break;; 
                8) release="plucky"; break;; 
                q) echo "Operation cancelled"; exit 1;;
                *) echo "Invalid option: $number. Please try again.";;
            esac
        done
        version=$(curl -s "${ubuntu_rootfs_base_url}${release}/release/" | grep -oE "ubuntu-base-[0-9]+\.[0-9]+-base-${hardware_machine}\.tar\.gz" | head -n 1 | sed -E 's/ubuntu-base-([0-9]+\.[0-9]+)-.*/\1/')
        download_url="${ubuntu_rootfs_base_url}${release}/release/ubuntu-base-${version}-base-${hardware_machine}.tar.gz"
    elif [ "$distro" = "alpine" ]; then
        distro_name='Alpine Linux'
        echo "[1] alpine minirootfs latest"
        echo "[2] alpine netboot latest"
        echo "[3] alpine rpi latest"
        echo "[4] alpine uboot latest"
        while true; do
            printf "Enter a number (1-4, or 'q' to quit): "
            read -r number
            case "$number" in
                1) rootfs="minirootfs";break;;
                2) rootfs="netboot"; break;;
                3) rootfs="rpi"; break;;
                4) rootfs="uboot";break;;
                q) echo "Operation cancelled"; exit 1;;
                *) echo "Invalid option: $number. Please try again.";;
            esac
        done
        hwm_alpine=$(echo $hardware_machine | sed s/arm64/aarch64/g | sed s/amd64/x86_64/g | sed s/i386/x86/g)
        download_url="$alpine_rootfs_base_url$hwm_alpine/alpine-$rootfs-$(curl -s "$alpine_rootfs_base_url$hwm_alpine/" | grep -oE 'alpine-.*[0-9]+\.[0-9]+\.[0-9]+[^"]*(.tar.gz|.tar|.img)' | sed -E 's/.*([0-9]+\.[0-9]+\.[0-9]+).*/\1/' | sort -V | tail -n 1)-$hwm_alpine.tar.gz"
    elif [ "$distro" = "kali" ]; then
        distro_name='Kali Linux'
        echo "[1] kali linux full"
        echo "[2] kali linux minimal"
        echo "[3] kali linux nano"
        while true; do
            printf "Enter a number (1-3, or 'q' to quit): "
            read -r number
            case "$number" in
                1) rootfs="full"; break;;
                2) rootfs="minimal"; break;;
                3) rootfs="nano"; break;;
                q) echo "Operation cancelled"; exit 1;;
                *) echo "Invalid option: $number. Please try again.";;
            esac
        done
        version="$(curl -s $kali_rootfs_base_url | grep -oE "kali-nethunter-[0-9]+\.[0-9]+-generic-${hardware_machine}-${rootfs}\.zip" | head -n 1 | sed -E 's/kali-nethunter-([0-9]+\.[0-9]+)-.*/\1/')"
        download_url="${kali_rootfs_base_url}current/kali-nethunter-${version}-generic-${hardware_machine}-${rootfs}\.zip"
    elif [ "$distro" = "debian" ]; then
        distro_name='Debian'
        echo "[1] Debian (AnLinux)"
        echo "[2] Debian bullseye (proot-distro)"
        echo "[3] Debian bookworm (proot-distro)"
        while true; do
            printf "Enter a number (1-3, or 'q' to quit): "
            read -r number
            case "$number" in
                1) rootfs="debian"; break;;
                2) rootfs="debian_bullseye"; break;;
                3) rootfs="debian_bookworm";break;;
                q) echo "Operation cancelled"; exit 1;;
                *) echo "Invalid option: $number. Please try again.";;
            esac
        done
        case "$rootfs" in
             debian) download_url="$debian_rootfs_base_url_anlinux$hardware_machine/debian-rootfs-$hardware_machine.tar.xz";;
             debian_bullseye) download_url="${debian_rootfs_base_url_prootdistro}debian-bullseye-$(echo $hardware_machine | sed s/arm64/aarch64/ | sed s/amd64/x86_64/ | sed s/i386/i686/ | sed s/armhf/arm/)-pd-v4.7.0.tar.xz";;
             debian_bookworm) download_url="${debian_rootfs_base_url_prootdistro}debian-bookworm-$(echo $hardware_machine | sed s/arm64/aarch64/ | sed s/amd64/x86_64/ | sed s/i386/i686/ | sed s/armhf/arm/)-pd-v4.7.0.tar.xz";;
        esac
    elif [ "$distro" = "parrot" ]; then
        distro_name='Parrot OS'
        download_url="$parrot_rootfs_base_url$hardware_machine/parrot-rootfs-$hardware_machine.tar.xz"
    elif [ "$distro" = "archlinux" ]; then
        distro_name='Arch Linux'
        case "$hardware_machine" in
             amd64) download_url="${archlinux_rootfs_base_url}archlinux-bootstrap-$(echo "$hardware_machine" | sed s/amd64/x86_64/).tar.zst";;
             armhf | arm64) download_url="${archlinux_rootfs_base_url_arm}ArchLinuxARM-$(echo "$hardware_machine" | sed 's/arm64/aarch64/; s/amd64/x86_64/; s/armhf/armv7/')-latest.tar.gz";;
        esac
    elif [ "$distro" = "artix" ]; then
        distro_name='Artix Linux'
        download_url="${artix_rootfs_base_url}artix-aarch64-pd-v4.6.0.tar.xz"
    elif [ "$distro" = "deepin" ]; then
        distro_name='Deepin'
        download_url="${deepin_rootfs_base_url}deepin-$(echo $hardware_machine | sed s/arm64/aarch64/ | sed s/amd64/x86_64/)-pd-v4.16.0.tar.xz"
    elif [ "$distro" = "fedora" ]; then
        distro_name='Fedora'
        echo "[1] fedora 4.24.0"
        echo "[2] fedora 4.23.0"
        echo "[3] fedora 4.17.3"
        echo "[4] fedora 4.15.0"
        while true; do
            printf "Enter a number (1-4, or 'q' to quit): " 
            read -r number
            case "$number" in
                1) release_version="4.24.0"; break;;
                2) release_version="4.23.0"; break;;
                3) release_version="4.17.3"; break;;
                4) release_version="4.15.0"; break;;
                q) echo "Operation cancelled"; exit 1;;
                *) echo "Invalid option: $number. Please try again.";;
            esac
        done
        download_url="${proot_distro_rootfs_base_url}/${release_version}/fedora-$(echo $hardware_machine | sed s/arm64/aarch64/ | sed s/amd64/x86_64/)-pd-${release_version}.tar.xz"
    
    elif [ "$distro" = "openkylin" ]; then
        distro_name='OpenKylin'
        download_url="${openkylin_rootfs_base_url}openkylin-$(echo $hardware_machine | sed s/arm64/aarch64/ | sed s/amd64/x86_64/)-pd-v4.10.0.tar.xz"
        elif [ "$distro" = "rocky" ]; then
        distro_name='Rocky Linux'
        download_url="${rocky_rootfs_base_url}rocky-$(echo $hardware_machine | sed s/arm64/aarch64/ | sed s/amd64/x86_64/)-pd-v4.20.0.tar.xz"
        elif [ "$distro" = "chimera" ]; then
        distro_name='Chimera Linux'
        echo "[1] chimera full"
        echo "[2] chimera minimal"
        while true; do
            printf "Enter a number (1-2, or 'q' to quit): "
            read -r number
            case "$number" in
                1) rootfs="full"; break;;
                2) rootfs="bootstrap"; break;;
                q) echo "Operation cancelled"; exit 1;;
                *) echo "Invalid option: $number. Please try again.";;
            esac
        done
        version="$(curl -s ${chimera_rootfs_base_url}latest | grep -oE "chimera-linux-$(echo $hardware_machine | sed s/arm64/aarch64/ | sed s/amd64/x86_64/)-ROOTFS-[0-9]{8}-${rootfs}\.tar.gz" | sed -E "s/.*chimera-linux-$(echo $hardware_machine | sed s/arm64/aarch64/ | sed s/amd64/x86_64/)-ROOTFS-([0-9]{8})-${rootfs}\.tar\.gz/\1/" | head -n 1)"
        download_url="${chimera_rootfs_base_url}latest/chimera-linux-$(echo $hardware_machine | sed s/arm64/aarch64/ | sed s/amd64/x86_64/)-ROOTFS-${version}-${rootfs}\.tar.gz"
       elif [ "$distro" = "adelie" ]; then
        distro_name='Adélie Linux'
        echo "[1] adelie linux full"
        echo "[2] adelie linux minimal"
        while true; do
            printf "Enter a number (1-2, or 'q' to quit): "
            read -r number
            case "$number" in
                1) rootfs="full"; break;;
                2) rootfs="minimal"; break;;
                q) echo "Operation cancelled"; exit 1;;
                *) echo "Invalid option: $number. Please try again.";;
            esac
        done
        version=$(curl -s "$adelie_rootfs_base_url" | grep -oE "adelie-rootfs-${rootfs}-$(echo $hardware_machine | sed s/arm64/aarch64/ | sed s/amd64/x86_64/ | sed s/armhf/armv7/ | sed s/i686/pmmx/)-[^\" ]+-[0-9]{8}\.txz" | sed -E 's/.*-([0-9]{8})\.txz/\1/' | head -n 1);
        download_url="${adelie_rootfs_base_url}adelie-rootfs-${rootfs}-$(echo $hardware_machine | sed s/arm64/aarch64/ | sed s/amd64/x86_64/ | sed s/armhf/armv7/ | sed s/i686/pmmx/)-1.0-beta6-${version}.txz"
    elif [ "$distro" = "manjaro" ]; then
        distro_name='Manjaro'
        download_url="${manjaro_rootfs_base_url}manjaro-$(echo $hardware_machine | sed s/arm64/aarch64/)-pd-v4.14.1.tar.xz"
    elif [ "$distro" = "opensuse" ]; then
        distro_name='OpenSuse'
        download_url="${opensuse_rootfs_base_url}opensuse-$(echo $hardware_machine | sed s/arm64/aarch64/g | sed s/amd64/x86_64/g | sed s/i386/i686/g | sed s/armhf/arm/g)-pd-v4.6.0.tar.xz"
    elif [ "$distro" = "pardus" ]; then
        distro_name='Pardus'
        download_url="${pardus_rootfs_base_url}pardus-$(echo $hardware_machine | sed s/arm64/aarch64/g | sed s/amd64/x86_64/g | sed s/i386/i686/g | sed s/armhf/arm/g)-pd-v4.6.0.tar.xz"
    elif [ "$distro" = "backbox" ]; then
        distro_name='BackBox'
        download_url="$backbox_rootfs_base_url$hardware_machine/backbox-rootfs-$hardware_machine.tar.xz"
    elif [ "$distro" = "centos" ]; then
        distro_name='CentOS'
        download_url="${centos_rootfs_base_url}${hardware_machine}/centos-rootfs-${hardware_machine}.tar.xz"
    elif [ "$distro" = "centos_stream" ]; then
        distro_name='CentOS Stream'
        download_url="${centos_stream_rootfs_base_url}${hardware_machine}/centos_stream-rootfs-${hardware_machine}.tar.xz"
        elif [ "$distro" = "gentoo" ]; then
        distro_name='Gentoo Linux'
        version=$(curl -s "https://distfiles.gentoo.org/releases/$(echo $hardware_machine | sed 's/armhf/armv7a/')/autobuilds/current-stage3-$(echo $hardware_machine | sed 's/armhf/armv7a/')-openrc/" | grep -oE "stage3-$(echo $hardware_machine | sed 's/armhf/armv7a/')-openrc-[0-9]{8}T[0-9]{6}Z\.tar\.xz" | sed -E "s/.*stage3-$(echo $hardware_machine | sed 's/armhf/armv7a/')-openrc-([0-9]{8}T[0-9]{6}Z)\.tar\.xz/\1/" | head -n 1)
        download_url="${gentoo_rootfs_base_url}$(echo $hardware_machine | sed 's/armhf/armv7a/')/autobuilds/current-stage3-$(echo $hardware_machine | sed 's/armhf/armv7a/')-openrc/stage3-$(echo $hardware_machine | sed 's/armhf/armv7a/')-openrc-${version}.tar.xz"
    elif [ "$distro" = "void" ]; then
        distro_name='Void Linux'
        download_url="${void_rootfs_base_url}current/void-$(echo $hardware_machine | sed s/arm64/aarch64/g | sed s/amd64/x86_64/g | sed s/i386/i686/g | sed s/armhf/armv7l/g)-ROOTFS-$(curl -s ${void_rootfs_base_url}current/ | grep -oE 'void-.*-ROOTFS-[0-9]+\.tar\.xz' | head -n 1 | sed -E 's/.*-ROOTFS-([0-9]+)\.tar\.xz/\1/').tar.xz"
    else
        echo "Unavailable distro: $distro"
        exit 90
    fi

    if [ "" = "$download_url" ]; then
        echo "Unsupported machine hardware: $(uname -m)"
        exit 87
    fi
    if ! wget --spider -q -T 10 -t 1 "$download_url"; then
        echo "Failed to access URL: $download_url"
        echo "The architecture '$hardware_machine' may not be supported or the URL is unavailable."
        exit 87
    fi
    if [ -f "$chroot_distro_path/.rootfs/$distro.tar.xz" ]; then
        echo "Already downloaded."
        exit 89
    fi

    if ! wget -O "$chroot_distro_path/.rootfs/$distro.tar.xz" "$download_url"; then
        echo "Failed to download the $distro_name Rootfs."
        if [ -e "$chroot_distro_path/.rootfs/$distro.tar.xz" ]; then
            rm "$chroot_distro_path/.rootfs/$distro.tar.xz"
        fi
        exit 88
    fi
}

chroot_distro_check_if_supported() {
    for distro in $supported_distros; do
        if [ "$distro" = "$1" ]; then
            return 0
        fi
    done
    echo "unavailable distro $1"
    exit 1
}

chroot_distro_find_processes_with_open_files() {
    path="$1"
    if [ "" != "$busyboxlsof" ]; then
        # busybox has own format for lsof output
        lsof | grep -F "$path" | grep -Eo '^[[:digit:]]+' | sort -n | uniq
    else
        lsof | grep -F "$path" | cut -c10- | grep -Eo '^ *[[:digit:]]+' | grep -Eo '[[:digit:]]+' | sort -n | uniq
    fi
}

chroot_distro_find_all_mount_points() {
    path="$1"
    mount | grep -F "$path" | grep -Eo '^[[:alnum:][:punct:]\/]+ on [[:alnum:][:punct:]\/]+' | grep -Eo '[[:alnum:][:punct:]\/]+$'
}

chroot_distro_find_all_loopback_mount_points() {
    path="$1"
    losetup -a | grep -F "$path" | grep -Eo '^[^:]+'
}

chroot_distro_delete() {
    chroot_distro_check_if_supported "$1"

    archive_path="$chroot_distro_path/.rootfs/$1.tar.xz"
    if [ -f "$archive_path" ]; then
        rm "$archive_path"
    else
        echo "$1 not downloaded"
        exit 1
    fi
}

list_mount_points() {
    distro_path="$1"
    
    for point in $system_points; do
        echo "$distro_path$point"
    done

    for storage in /storage/*; do
        echo "$distro_path$storage"
    done
}

chroot_distro_mount_system_point() {
    path_to_mount="$1"
    mount_point="$2"
    if [ ! -e "$path_to_mount" ]; then
        echo "Warning: Missing system path $path_to_mount, skipping"
        return
    fi
    if [ ! -d "$mount_point" ]; then
        if ! mkdir -p "$mount_point"; then
            echo "creating mount point $mount_point failed"
            exit 1
        fi
    fi
    if mountpoint -q "$mount_point"; then
        # nothing to do, already mounted
        return
    fi
    if [ "$path_to_mount" = "/dev/pts" ]; then
        if ! mount -t devpts devpts "$mount_point"; then
            echo "could not mount devpts to $mount_point"
            exit 1
        fi
    elif [ "$path_to_mount" = "/tmp" ]; then
       if ! mount -t tmpfs tmpfs "$mount_point"; then
            echo "could not mount tmpfs to $mount_point"
            exit 1
        fi
    elif [ "$path_to_mount" = "/run" ]; then
       if ! mount -t tmpfs tmpfs "$mount_point"; then
            echo "could not mount tmpfs to $mount_point"
            exit 1
        fi
    elif [ "$path_to_mount" = "/var/tmp" ]; then
       if ! mount -t tmpfs tmpfs "$mount_point"; then
            echo "could not mount tmpfs to $mount_point"
            exit 1
        fi
     elif [ "$path_to_mount" = "/var/run" ]; then
       if ! mount -t tmpfs tmpfs "$mount_point"; then
            echo "could not mount tmpfs to $mount_point"
            exit 1
        fi
     elif [ "$path_to_mount" = "/dev/shm" ]; then
       if ! mount -t tmpfs tmpfs "$mount_point"; then
            echo "could not mount tmpfs to $mount_point"
            exit 1
        fi
    else
        if ! mount --bind "$path_to_mount" "$mount_point"; then
            echo "could not mount $path_to_mount to $mount_point"
            exit 1
        fi 
    fi
}

mount_android_dirs() {
  for dir in /*; do
    [ -d "$dir" ] || continue
    case "$dir" in
      /storage|/bin|/boot|/etc|/home|/lib|/media|/opt|/root|/run|/sbin|/srv|/usr|/var|/linkerconfig)
        ;;
      *)
        echo " $system_points " | grep -q " $dir " && continue
        system_points="$system_points $dir"
        ;;
    esac
  done
}

chroot_distro_force_unmount() {
     mount_point="$1"
     # first try to kill all processes before trying to unmount anything
     # note: close from earlier to later processes to ensure that no new worker processes are created during killing
     chroot_distro_find_processes_with_open_files "$mount_point/" | xargs -I {} kill {} > /dev/null 2>&1
     # before normal unmounts, go through all loopback devices
     # note: in reverse order in case there is loopback mount from inside the loopback mount (quite contrived case but just in case...)
     chroot_distro_find_all_loopback_mount_points "$mount_point/" | sort -r | xargs -I {} umount {} > /dev/null 2>&1
     # try to unmount everything found
     # note: using reverse sort to ensure that mounts residing deeper in the file system will be unmounted first
     chroot_distro_find_all_mount_points "$mount_point/" | sort -r | xargs -I {} umount {} > /dev/null 2>&1
     # then hope for the best...
}

chroot_distro_mount_system_points() {
    distro_path="$1"
    if [ "1" = "$android_bind_val" ]; then
        mount_android_dirs
    fi
    if [ "1" = "$ram_bind_val" ]; then
        system_points="$system_points /tmp /run /var/tmp /var/run /dev/shm"
    fi
    for point in $system_points; do
        chroot_distro_mount_system_point "$point" "$distro_path$point"
    done
}

chroot_distro_unmount_system_point() {
    mount_point="$1"
    force="$2"
    if [ ! -e "$mount_point" ]; then
        # nothing to do, mount point missing
        return
    fi
    if ! mountpoint -q "$mount_point"; then
        # nothing to do, already unmounted
        return
    fi
    if [ "yes" = "$force" ]; then
       chroot_distro_force_unmount "$mount_point/" 
    fi
    # no need to check for the success as the caller will take care of that
    if ! umount "$mount_point" || true; then
    echo "Warning: Failed to unmount $mount_point"
    fi
}

chroot_distro_unmount_system_points() {
    distro_path="$1"
    force="$2"
    for point in $system_points; do
        chroot_distro_unmount_system_point "$distro_path$point" "$force"
    done
} 

chroot_distro_check_if_system_point_mounted() {
    mount_point="$1"
    if [ ! -e "$mount_point" ]; then
        # nothing to do, mount point missing
        return 1
    fi
    if mountpoint -q "$mount_point" 2>/dev/null || true; then
       return 0
    else
       return 1
    fi
}

chroot_distro_check_if_system_points_mounted() {
    distro_path="$1"
    for point in $system_points; do
        path="$distro_path$point"
        if chroot_distro_check_if_system_point_mounted "$path"; then
            return 0
        fi
    done
    return 1
}

chroot_distro_check_archive_file_type() {
    archive_path="$1"

    # -l option would be more efficient but unfortunately busybox implementation may not support it
    if gunzip -t "$archive_path" 1>/dev/null 2>&1 ; then
        echo "gzip"
        return
    fi
    # -l option would be more efficient but unfortunately busybox implementation may not support it
    if xz -t "$archive_path" 1>/dev/null 2>&1 ; then
        echo "xz"
        return
    fi
    if tar -tf "$archive_path" 1>/dev/null 2>&1 ; then
        # either it is real tar file, or something else which isn't gunzip or xz
        echo "tar"
        return
    fi
}

chroot_distro_find_su() {
    root=$1
    su_command=""
    if [ -f "$root/bin/su" ] || [ -L "$root/bin/su" ]; then
        su_command=/bin/su
    elif [ -f "$root/usr/bin/su" ] || [ -L "$root/usr/bin/su" ]; then
        su_command=/usr/bin/su
    elif [ -f "$root/usr/local/bin/su" ] || [ -L "$root/usr/local/bin/su" ]; then
        su_command=/usr/local/bin/su
    fi
    echo "$su_command"
}

chroot_distro_jail() {
    distro_path=$1
    command=$2
    su_command=$(chroot_distro_find_su "$distro_path")

    if [ "" != "$su_command" ]; then
        (
            # try to ensure that su will do as proper login as possible to ensure consistent environment
            unset PREFIX;
            if [ "" != "$command" ]; then
                # shellcheck disable=SC1007
                PATH= chroot "$distro_path/" "$su_command" - root -c "$command"
            else
                # shellcheck disable=SC1007
                PATH= chroot "$distro_path/" "$su_command" - root
            fi
        )
        return
    fi

    echo "Warning: Missing 'su' command, can't do a proper login. Please, install 'su'"
    echo "as soon as possible to ensure consistent login environment."

    # ensure a sane PATH contents for the shell
    JAIL_PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

    JAIL_HOME=/
    if [ -d "$distro_path/root" ]; then
        JAIL_HOME=/root
    fi

    (
        # try to ensure consistent environment
        unset HISTFILE;
        unset TMPDIR;
        unset PREFIX;
        unset BOOTCLASSPATH;
        unset SYSTEMSERVERCLASSPATH;
        unset LD_LIBRARY_PATH;
        if [ "" != "$command" ]; then
            SHELL=/bin/sh HOME="$JAIL_HOME" PATH="$JAIL_PATH" chroot "$distro_path/" /bin/sh -lc "$command"
        else
            SHELL=/bin/sh HOME="$JAIL_HOME" PATH="$JAIL_PATH" chroot "$distro_path/" /bin/sh -l
        fi
    )
}

prepare_chroot_distro() {
   resolvconf="$distro_path"/etc/resolv.conf
   if [ -L "$resolvconf" ] && [ ! -f "$resolvconf" ]; then
      # broken link
      rm "$resolvconf"
   fi
   echo "nameserver 8.8.8.8" > "$resolvconf"
   echo "nameserver 8.8.4.4" >> "$resolvconf"
   cp /etc/hosts "$distro_path"/etc/hosts
  {
   echo "3003 aid_inet"
   echo "3004 aid_net_raw"
   echo "1003 aid_graphics"
   echo "1003 aid_graphics"
   echo "1004 aid_input"
   echo "1005 aid_audio"
   echo "1006 aid_video"
   echo "1007 aid_drm"
  } >> "$distro_path/etc/group"
   # Add usermod for _apt only if the distro is Debian-based
   if chroot "$distro_path" /bin/id _apt >/dev/null 2>&1 || true; then
      chroot "$distro_path" /sbin/usermod -g 3003 -G 3003,3004 -a _apt 2>/dev/null
   fi
   chroot "$distro_path" /sbin/usermod -G 3003 -a root 2>/dev/null || true
   timezone="$(getprop persist.sys.timezone)"
   chroot "$distro_path" /bin/ln -sf /usr/share/zoneinfo/"$timezone" /etc/localtime 2>/dev/null || true
} 

chroot_distro_install() {
    distro=$1
    chroot_distro_check_if_supported "$distro"

    archive_path="$chroot_distro_path/.rootfs/$distro.tar.xz"
    if [ ! -f "$archive_path" ]; then
        echo "$distro not downloaded"
        exit 1
    fi

    distro_path="$chroot_distro_path/$distro"
    if [ -d "$distro_path" ]; then
        echo "$distro already installed"
        exit 1
    fi

    common_path="$( chroot_distro_find_archive_common_path "$archive_path" )"
    # shellcheck disable=SC2181
    # we want both the output and error code, so need indirection
    if [ $? -ne 0 ]; then
        # Something went wrong with finding the archive common path
        return $?
    fi
    if [ "" = "$common_path" ]; then
        common_path="."
    fi
    rootdir="$( echo "$common_path" | cut -f1 -d/ )"
    if [ "$rootdir" != "$common_path" ]; then
        echo "Unsupported archive. rootfs archive is expected to have only at most one subdirectory before the actual content."
        exit 1
    fi
    archive_type=${archive_type-$(chroot_distro_check_archive_file_type "$archive_path")}
    if [ "" = "$archive_type" ]; then
        echo "Error: unsupported or corrupt archive"
        exit 5
    fi
    if [ "." = "$rootdir" ]; then
        mkdir -p "$distro_path"
        if ! tar -xf "$archive_path" -C "$distro_path/"; then
            echo "Error: Unpacking the archive failed"
            exit 5
        fi
    else
        tar -xf "$archive_path" -C "$chroot_distro_path/"
        tar_status=$?
        if [ $tar_status -ne 0 ] && [ ! -e "$chroot_distro_path/$rootdir" ]; then
            # can bail out early as no files were unpacked
            echo "Error: Unpacking the archive failed"
            exit 5
        fi
        mv "$chroot_distro_path/$rootdir" "$distro_path"
        if [ $tar_status -ne 0 ]; then
            # can bail out only when the environment is in semi consistent state
            echo "Error: Unpacking the archive failed"
            exit 5
        fi
    fi

    chroot_distro_mount_system_points "$distro_path" 
    prepare_chroot_distro
    chroot_distro_jail "$distro_path"
}

chroot_distro_list_unmount_issues() {
    distro_path=$1
    command=$2
    mode=$3
    force=$4
    mounts=$5
    loopbacks=$6
    open_files=$7

    unset maybe_more
    if [ "all" != "$mode" ]; then
        maybe_more=true
    fi
    # note: if there is still system mount points mounted without a valid reason, please create a bug report so that it can be investigated
    echo 'distro is potentially running - if needed shutdown the distro, and unmount mounted folders'
    echo
    if [ "yes" != "$force" ]; then
        echo "You can try running $command again with -f(--force) option to automatically close/unmount files/folders mentioned below."
        echo 'Please note, that using --force option may close more programs than intended, so use it with care.'
    fi
    echo
    echo "open files under $distro_path${maybe_more+ (which affects unmounting, there may be more)}:"
    if [ "" = "$lsofpath" ]; then
        echo "Warning: supported lsof not found, run \`lsof | grep -F '$distro_path/'\` manually"
    fi
    echo "${open_files:-Not found}"
    echo "end of open files"
    echo
    echo "mount points under $distro_path${maybe_more+ (which affects unmounting, there may be more)}:"
    echo "${mounts:-Not found}"
    echo "end of mount points"
    echo
    echo "loopback devices under $distro_path${maybe_more+ (which affects unmounting, there may be more)}:"
    echo "${loopbacks:-Not found}"
    echo "end of loopback devices"
    echo
    echo "If there is no open files, mount points ${maybe_more-(outside of system mount points) }or loopback devices,"
    echo "then check for anonymous inodes and inotify watches"
}

chroot_distro_uninstall() {
    chroot_distro_check_if_supported "$1" 

    distro_path="$chroot_distro_path/$1"
    force=$2
    command=$3

    if [ -d "$distro_path" ]; then
        if [ "yes" = "$force" ]; then
            chroot_distro_force_unmount "$distro_path/" 
        fi
        chroot_distro_unmount_system_points "$distro_path" no
        mounts=$(mount | grep -F "$distro_path")
        loopbacks=$(losetup -a | grep -F "$distro_path")
        open_files=$(lsof | grep -F "$distro_path")
        if [ "" != "$mounts" ] || [ "" != "$loopbacks" ] || [ "" != "$open_files" ]; then
            chroot_distro_list_unmount_issues "$distro_path" "$command" 'all' "$force" "$mounts" "$loopbacks" "$open_files"
            exit 1
        fi

        # when reaching this point it is assumed that uninstalling the distro is ok, no irreversible changes to distro before this line

        # ensure that there is no symbolic links before nuking the rootfs, symbolic links may point outside of rootfs when outside of the chroot
        find "$distro_path" -type l -exec unlink {} \;
        rm -rf "$distro_path"
    else
        echo "$1 not installed"
        exit 1
    fi
}

chroot_distro_backup() {
    distro=$1
    custom_path=$2
    chroot_distro_check_if_supported "$distro" 

    distro_path="$chroot_distro_path/$1"
    if [ ! -d "$distro_path" ]; then
        echo "distro not installed, no need to backup"
        exit
    fi

    # Check system mount points, to ensure that we are not backing up a running system.
    # If system mount points are mounted then those will be backed up as well but in most
    # cases those are not wanted, as the restore will not work properly (mounts will shadow
    # the content). If data/sdcard etc. are needed to backup then it is better to do it
    # with different tool (for example twrp) and/or from inside the chroot
    if chroot_distro_check_if_system_points_mounted "$distro_path"; then
        echo "distro is potentially running - if needed shutdown the distro, and unmount system mount points ($script unmount $1) before proceeding"
        exit
    fi

    open_file_count=$(lsof | grep -Fc "$distro_path")
    if [ "" = "$lsofpath" ]; then
        echo "Warning: supported lsof not found, open files and/or programs currently running in jail will not be found."
        echo "In the case of errors run \`lsof | grep -F '$distro_path/'\` manually"
    elif [ "$open_file_count" -ne 0 ]; then
        echo "Warning: Open files detected, backup may fail (at least partially)"
    fi

    # mounted volumes should be backed up outside of this script as it may not work as intended
    # (same reasons as system mount points)
    mounts=$(mount | grep -F "$distro_path")
    loopbacks=$(losetup -a | grep -F "$distro_path")
    if [ -n "$mounts" ] || [ -n "$loopbacks" ]; then
        echo "distro is potentially running - if needed shutdown the distro, and unmount mounted folders"
        echo
        echo "To automatically unmount mount points mentioned below, run \`$script unmount -a $1\`"
        echo
        echo "mount points under $distro_path:"
        echo "${mounts:-Not found}"
        echo "end of mount points"
        echo
        echo "loopback devices under $distro_path:"
        echo "${loopbacks:-Not found}"
        echo "end of loopback devices"
        exit 1
    fi

    if [ "" = "$custom_path" ]; then
        backup_path="$chroot_distro_path/.backup/$1.tar.xz"
        if [ -f "$backup_path" ]; then
            echo "backup already exist, unbackup and try agin"
            exit 1
        fi
        (
            cd "$chroot_distro_path" || exit 1;
            if ! tar -caf "$backup_path" "$distro" 2>/dev/null || true; then
                echo "Error: creating the backup failed"
                exit 5
            fi
        )
    else
        absolute_custom_path="$custom_path"
        if [ "$custom_path" = "${custom_path#/}" ]; then
            # can not have a relative path as current directory will change
            absolute_custom_path="$PWD/$custom_path"
        fi
        (
            cd "$chroot_distro_path" || exit 1;
            if ! tar -caf "$absolute_custom_path" "$distro" 2>/dev/null || true; then
                echo "Error: creating the backup failed"
                exit 5
            fi
        )
    fi
}

chroot_distro_find_archive_common_path() {
    archive_path=$1
    archive_type=${archive_type-$(chroot_distro_check_archive_file_type "$archive_path")}
    if [ "" = "$archive_type" ]; then
        echo "Error: unsupported or corrupt archive" >&2
        exit 5
    fi
    paths_to_check="$(tar -tf "$archive_path" 2>/dev/null)"

    i=1
    prev_path=

    while [ $i -lt 100 ]
    do
        path=$(echo "$paths_to_check" | cut -f1-"$i" -d/ | uniq -u)
        if [ -z "$path" ]; then
            prev_path=$(echo "$paths_to_check" | cut -f1-"$i" -d/ | uniq)
        else
            echo "$prev_path"
            break
        fi
        i=$((i+1))
    done
}

chroot_distro_unbackup() {
    chroot_distro_check_if_supported "$1"

    backup_path="$chroot_distro_path/.backup/$1.tar.xz"
    if [ -f "$backup_path" ]; then
        rm "$backup_path"
    else
        echo "backup not found $1"
        exit 1
    fi
}

chroot_distro_restore() {
    distro="$1"
    custom_backup_path="$2"
    restore_defaults="$3"
    force="$4"
    chroot_distro_check_if_supported "$distro"

    distro_path="$chroot_distro_path/$distro"
    if [ -d "$distro_path" ]; then
        echo "distro already installed , uninstall and try again"
        exit 1
    fi

    if [ "" = "$custom_backup_path" ]; then
        backup_path="$chroot_distro_path/.backup/$1.tar.xz"
    else
        absolute_backup_path="$custom_backup_path"
        if [ "$custom_backup_path" = "${custom_backup_path#/}" ]; then
            # can not have a relative path as current directory may and will change
            absolute_backup_path="$PWD/$custom_backup_path"
        fi
        backup_path="$absolute_backup_path"
    fi

    if [ ! -f "$backup_path" ]; then
        echo "backup not found"
        exit 1
    fi

    common_path="$(chroot_distro_find_archive_common_path "$backup_path")"
    # shellcheck disable=SC2181
    # we want both the output and error code, so need indirection
    if [ $? -ne 0 ]; then
        # Something went wrong with finding the archive common path
        return $?
    fi
    if [ "" = "$common_path" ]; then
        common_path="."
    fi
    rootdir="$( echo "$common_path" | cut -f1 -d/ )"

    archive_type=${archive_type-$(chroot_distro_check_archive_file_type "$backup_path")}
    if [ "" = "$archive_type" ]; then
        echo "Error: unsupported or corrupt archive"
        exit 5
    fi

    if [ "." = "$rootdir" ]; then
        # backup has relative path, restoring is not a problem
        mkdir -p "$distro_path"
        if ! tar -xf "$backup_path" -C "$distro_path/" 2>/dev/null || true; then
            echo "Error: Unpacking the archive failed"
            exit 5
        fi
    elif [ "data" = "$rootdir" ] && [ "yes" = "$force" ]; then
        # Uses old format of backups. Accept only if user has reviewed the content as the backup needs to be
        # applied from root directory, potentially rendering the system unstable and/or be compromised.
        # Also, backup may contain files which will not be visible from running system and will potentially
        # fill the internal storage. There is also possibility of using wrong backup.
        (
            cd /
            if ! tar -xf "$backup_path" 2>/dev/null || true; then
                echo "Error: Unpacking the archive failed"
                exit 5
            fi
        )
    elif [ "data" = "$rootdir" ]; then
        echo "Will restore from root directory, review the contents and use --force."
        echo "Warning: Old style backup. May contain file backups from sdcard and other system mount points."
        echo "Restore may fail if not enough space on internal storage, and restored files from system mount"
        echo "points will be shadowed by system mounts."
        if [ "/$common_path" != "$distro_path" ]; then
            echo "Warning: Backup may be for different distro:"
            echo "- expected common denominator path: $distro_path"
            echo "- archive had following common denominator path: /$common_path"
        fi
        exit 4
    elif [ "$distro" = "$rootdir" ]; then
        # new format backups
        (
            cd "$chroot_distro_path" || exit 1;
            if ! tar -xf "$backup_path" 2>/dev/null || true; then
                echo "Error: Unpacking the archive failed"
                exit 5
            fi
        )
    else
        echo "Backup may be for wrong distro (root directory $rootdir), review the backup before proceeding"
        exit 4
    fi

    chroot_distro_mount_system_points "$distro_path" no

    if [ "yes" = "$restore_defaults" ]; then
       prepare_chroot_distro
    fi
    chroot_distro_jail "$distro_path"
}

chroot_distro_unmount() {
    distro="$1"
    force="$2"
    all="$3"

    if [ "$distro" = "all" ]; then
       for udistro in $supported_distros; do
           if [ -d "$chroot_distro_path/$udistro/" ]; then
               if chroot_distro_check_if_system_points_mounted "$chroot_distro_path/$udistro"; then
                  chroot_distro_unmount "$udistro" "$force" "$all"
               fi
           fi
       done 
       return 0
    fi

    chroot_distro_check_if_supported "$distro" 

    distro_path="$chroot_distro_path/$distro"
    if [ ! -d "$distro_path" ]; then
        echo "$distro not installed"
        exit 1
    fi

    if [ "yes" = "$all" ]; then
        if [ "yes" = "$force" ]; then
            # first try to kill all processes before trying to unmount anything
            # note: close from earlier to later processes to ensure that no new worker processes are created during killing
            chroot_distro_find_processes_with_open_files "$distro_path/" | xargs -I {} kill {} > /dev/null 2>&1
        fi
        # before normal unmounts, go through all loopback devices
        # note: in reverse order in case there is loopback mount from inside the loopback mount (quite contrived case but just in case...)
        chroot_distro_find_all_loopback_mount_points "$distro_path/" | sort -r | xargs -I {} umount {} > /dev/null 2>&1
        # try to unmount everything found
        # note: using reverse sort to ensure that mounts residing deeper in the file system will be unmmounted first
        chroot_distro_find_all_mount_points "$distro_path/" | sort -r | xargs -I {} umount {} > /dev/null 2>&1
    else
        chroot_distro_unmount_system_points "$distro_path" "$force"
    fi

    if [ "yes" = "$all" ]; then
        mounts=$(mount | grep -F "$distro_path")
        loopbacks=$(losetup -a | grep -F "$distro_path")
        open_files=$(lsof | grep -F "$distro_path")
        # as all mount points are being unmounted, no need to test for system mount points separately
        system_mount_points_mounted=1
        mode=all
    else
        mounts=$(mount | grep -F "$distro_path" | list_mount_points "$distro_path")
        loopbacks=$(losetup -a | grep -F "$distro_path" | list_mount_points "$distro_path")
        open_files=$(lsof | grep -F "$distro_path" | list_mount_points "$distro_path")
        chroot_distro_check_if_system_points_mounted "$distro_path"
        system_mount_points_mounted=$?
        mode=system
    fi
    if [ "" != "$mounts" ] || [ "" != "$loopbacks" ] || [ "" != "$open_files" ] || [ "0" = "$system_mount_points_mounted" ]; then
        chroot_distro_list_unmount_issues "$distro_path" 'unmount' "$mode" "$force" "$mounts" "$loopbacks" "$open_files"
        exit 1
    fi
}

chroot_distro_command() {
    chroot_distro_check_if_supported "$1"

    command="$2"

    distro_path="$chroot_distro_path/$1"
    if [ ! -d "$distro_path" ]; then
        echo "$1 not installed"
        exit 1
    fi

    chroot_distro_mount_system_points "$distro_path" no

    chroot_distro_jail "$distro_path" "$command"
}

chroot_distro_login() {
    chroot_distro_check_if_supported "$1"

    distro_path="$chroot_distro_path/$1"
    if [ ! -d "$distro_path" ]; then
        echo "$1 not installed"
        exit 1
    fi

    chroot_distro_mount_system_points "$distro_path" no

    chroot_distro_jail "$distro_path"
}

chroot_distro_invalid_parameters() {
    echo "$script - $1"
    echo "try '$script help' for more information"
    exit 2
}

chroot_distro_user_check_parameters() {
    chroot_distro_invalid_parameters "unknonwn parameters"
}

chroot_distro_missing_distro() {
    chroot_distro_invalid_parameters "missing distro"
}

if [ $# -eq 0 ]; then
    chroot_distro_help
    exit
fi

command=$1
shift

if [ "$command" = "help" ]; then
    PARSED=$(getopt --options= --longoptions= --name "$0" -- "$@") || exit 2
    chroot_distro_help
elif [ "$command" = "list" ]; then
    PARSED=$(getopt --options= --longoptions= --name "$0" -- "$@") || exit 2
    eval set -- "$PARSED"
    while true; do
        case "$1" in
            --)
                shift
                break
                ;;
            *)
                echo "Programming error"
                exit 3
                ;;
        esac
    done
    if [ $# -ne 0 ]; then
        chroot_distro_user_check_parameters
    fi
    chroot_distro_list
elif [ "$command" = "download" ]; then
    PARSED=$(getopt --options= --longoptions= --name "$0" -- "$@") || exit 2
    eval set -- "$PARSED"
    while true; do
        case "$1" in
            --)
                shift
                break
                ;;
            *)
                echo "Programming error"
                exit 3
                ;;
        esac
    done
    if [ $# -eq 0 ]; then
        chroot_distro_missing_distro
    elif [ $# -ne 1 ]; then
        chroot_distro_user_check_parameters
    fi
    chroot_distro_warn_if_unsupported_busybox
    chroot_distro_download "$1"
elif [ "$command" = "redownload" ]; then
    PARSED=$(getopt --options= --longoptions= --name "$0" -- "$@") || exit 2
    eval set -- "$PARSED"
    while true; do
        case "$1" in
            --)
                shift
                break
                ;;
            *)
                echo "Programming error"
                exit 3
                ;;
        esac
    done
    if [ $# -eq 0 ]; then
        chroot_distro_missing_distro
    elif [ $# -ne 1 ]; then
        chroot_distro_user_check_parameters
    fi
    chroot_distro_download "$1"
elif [ "$command" = "delete" ]; then
    PARSED=$(getopt --options= --longoptions= --name "$0" -- "$@") || exit 2
    eval set -- "$PARSED"
    while true; do
        case "$1" in
            --)
                shift
                break
                ;;
            *)
                echo "Programming error"
                exit 3
                ;;
        esac
    done
    if [ $# -eq 0 ]; then
        chroot_distro_missing_distro
    elif [ $# -ne 1 ]; then
        chroot_distro_user_check_parameters
    fi
    chroot_distro_delete "$1"
elif [ "$command" = "install" ]; then
    PARSED=$(getopt --options=a --longoptions= --name "$0" -- "$@") || exit 2
    eval set -- "$PARSED"
    while true; do
        case "$1" in
            --)
                shift
                break
                ;;
            *)
                echo "Programming error"
                exit 3
                ;;
        esac
    done
    if [ $# -eq 0 ]; then
        chroot_distro_missing_distro
    elif [ $# -ne 1 ]; then
        chroot_distro_user_check_parameters
    fi
    chroot_distro_warn_if_unsupported_busybox
    chroot_distro_install "$1" 
elif [ "$command" = "uninstall" ]; then
    PARSED=$(getopt --options=f --longoptions=force --name "$0" -- "$@") || exit 2
    eval set -- "$PARSED"
    force=no
    while true; do
        case "$1" in
            -f|--force)
                force=yes
                shift
                ;;
            --)
                shift
                break
                ;;
            *)
                echo "Programming error"
                exit 3
                ;;
        esac
    done
    if [ $# -eq 0 ]; then
        chroot_distro_missing_distro
    elif [ $# -ne 1 ]; then
        chroot_distro_user_check_parameters
    fi
    chroot_distro_uninstall "$1" "$force" "$command"
elif [ "$command" = "reinstall" ]; then
    OPTS=af LONGOPTS=force
    PARSED=$(getopt --options=$OPTS --longoptions=$LONGOPTS --name "$0" -- "$@") || exit 2
    eval set -- "$PARSED"
    force=no
    while true; do
        case "$1" in
            -f|--force)
                force=yes
                shift
                ;;
            --)
                shift
                break
                ;;
            *)
                echo "Programming error"
                exit 3
                ;;
        esac
    done
    if [ $# -eq 0 ]; then
        chroot_distro_missing_distro
    elif [ $# -ne 1 ]; then
        chroot_distro_user_check_parameters
    fi
    chroot_distro_uninstall "$1" "$force" "$command"
    chroot_distro_install "$1" 
elif [ "$command" = "backup" ]; then
    PARSED=$(getopt --options= --longoptions= --name "$0" -- "$@") || exit 2
    eval set -- "$PARSED"
    while true; do
        case "$1" in
            --)
                shift
                break
                ;;
            *)
                echo "Programming error"
                exit 3
                ;;
        esac
    done
    if [ $# -eq 0 ]; then
        chroot_distro_missing_distro
    elif [ $# -gt 2 ]; then
        chroot_distro_user_check_parameters
    fi
    chroot_distro_backup "$1" "$2"
elif [ "$command" = "unbackup" ]; then
    PARSED=$(getopt --options= --longoptions= --name "$0" -- "$@") || exit 2
    eval set -- "$PARSED"
    while true; do
        case "$1" in
            --)
                shift
                break
                ;;
            *)
                echo "Programming error"
                exit 3
                ;;
        esac
    done
    if [ $# -eq 0 ]; then
        chroot_distro_missing_distro
    elif [ $# -ne 1 ]; then
        chroot_distro_user_check_parameters
    fi
    chroot_distro_unbackup "$1"
elif [ "$command" = "restore" ]; then
    OPTS=d LONGOPTS=default,force
    PARSED=$(getopt --options=$OPTS --longoptions=$LONGOPTS --name "$0" -- "$@") || exit 2
    eval set -- "$PARSED"
    restore_defaults=no
    force=no
    while true; do
        case "$1" in
            -d|--default)
                restore_defaults=yes
                shift
                ;;
            --force)
                force=yes
                shift
                ;;
            --)
                shift
                break
                ;;
            *)
                echo "Programming error"
                exit 3
                ;;
        esac
    done
    if [ $# -eq 0 ]; then
        chroot_distro_missing_distro
    elif [ $# -gt 2 ]; then
        chroot_distro_user_check_parameters
    fi
    chroot_distro_restore "$1" "$2" "$restore_defaults" "$force"
elif [ "$command" = "command" ]; then
    PARSED=$(getopt --options= --longoptions= --name "$0" -- "$@") || exit 2
    eval set -- "$PARSED"
    while true; do
        case "$1" in
            --)
                shift
                break
                ;;
            *)
                echo "Programming error"
                exit 3
                ;;
        esac
    done
    if [ $# -eq 0 ]; then
        chroot_distro_missing_distro
    elif [ $# -eq 1 ]; then
        chroot_distro_invalid_parameters "program missing"
    elif [ $# -ne 2 ]; then
        chroot_distro_user_check_parameters
    fi
    chroot_distro_command "$1" "$2"
elif [ "$command" = "login" ]; then
    PARSED=$(getopt --options= --longoptions= --name "$0" -- "$@") || exit 2
    eval set -- "$PARSED"
    while true; do
        case "$1" in
            --)
                shift
                break
                ;;
            *)
                echo "Programming error"
                exit 3
                ;;
        esac
    done
    if [ $# -eq 0 ]; then
        chroot_distro_missing_distro
    elif [ $# -ne 1 ]; then
        chroot_distro_user_check_parameters
    fi
    chroot_distro_login "$1"
elif [ "$command" = "unmount" ]; then
    PARSED=$(getopt --options=fa --longoptions=force,all --name "$0" -- "$@") || exit 2
    eval set -- "$PARSED"
    force=no
    all=no
    while true; do
        case "$1" in
            -f|--force)
                force=yes
                shift
                ;;
            -a|--all)
                all=yes
                shift
                ;;
            --)
                shift
                break
                ;;
            *)
                echo "Programming error"
                exit 3
                ;;
        esac
    done
    if [ $# -eq 0 ]; then
        chroot_distro_missing_distro
    elif [ $# -ne 1 ]; then
        chroot_distro_user_check_parameters
    fi
    chroot_distro_unmount "$1" "$force" "$all"
elif [ "$command" = "fixsuid" ]; then
    PARSED=$(getopt --options= --longoptions= --name "$0" -- "$@") || exit 2
    eval set -- "$PARSED"
    while true; do
        case "$1" in
            --)
                shift
                break
                ;;
            *)
                echo "Programming error"
                exit 3
                ;;
        esac
    done
    if [ $# -ne 1 ]; then
        chroot_distro_user_check_parameters
    fi
    case "$1" in
         enable) fixsuid enable;; 
         disable) fixsuid disable;; 
         *) echo "Unknown option $1";; 
    esac
elif [ "$command" = "ram-bind" ]; then
    PARSED=$(getopt --options= --longoptions= --name "$0" -- "$@") || exit 2
    eval set -- "$PARSED"
    while true; do
        case "$1" in
            --)
                shift
                break
                ;;
            *)
                echo "Programming error"
                exit 3
                ;;
        esac
    done
    if [ $# -ne 1 ]; then
        chroot_distro_user_check_parameters
    fi
    case "$1" in
         enable) ram_bind ram;; 
         disable) ram_bind disable && chroot_distro_unmount "all" "yes" "yes";; 
         *) echo "Unknown option $1";; 
    esac
elif [ "$command" = "android-bind" ]; then
    PARSED=$(getopt --options= --longoptions= --name "$0" -- "$@") || exit 2
    eval set -- "$PARSED"
    while true; do
        case "$1" in
            --)
                shift
                break
                ;;
            *)
                echo "Programming error"
                exit 3
                ;;
        esac
    done
    if [ $# -ne 1 ]; then
        chroot_distro_user_check_parameters
    fi
    case "$1" in
         enable) android_bind enable;; 
         disable) android_bind disable && chroot_distro_unmount "all" "yes" "yes";; 
         *) echo "Unknown option $1";; 
    esac
else
    chroot_distro_invalid_parameters "invalid command $command"
fi
